<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Styling Adventures · Callback</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body class="sa-body" style="padding:24px">
  <h1 class="sa-h1">Signing you in…</h1>
  <p class="sa-muted" id="msg">Exchanging code…</p>
  <p style="margin-top:12px"><a class="sa-link" href="/fan/">← Back to Fan Dashboard</a></p>

<script type="module">
(async () => {
  const msg = (t)=>document.getElementById('msg').textContent=t;

  // Load config (no-store so we never get a stale redirectUri)
  const cfg = await (await fetch('/config.v2.json?ts='+Date.now(), {cache:'no-store'})).json();

  // Normalize domains/URIs exactly like the app pages
  const PROD_CF = 'https://d1so4qr6zsby5r.cloudfront.net';
  const isLocal = location.origin.startsWith('http://localhost:');
  const EXPECTED_REDIRECT = isLocal ? 'http://localhost:5173/callback/' : `${PROD_CF}/callback/`;
  const EXPECTED_LOGOUT   = isLocal ? 'http://localhost:5173/'          : `${PROD_CF}/`;

  const region = cfg.region || 'us-east-1';
  const hosted = (cfg.hostedUiDomain || cfg.domain || '').trim();
  const domain = `https://${hosted}.auth.${region}.amazoncognito.com`;

  // Parse query
  const qs  = new URLSearchParams(location.search);
  const code  = qs.get('code');
  const state = qs.get('state') || '';
  const rtMatch = state.match(/^rt:([^|]+)\|/);         // state prefix "rt:/fan/|<nonce>"
  const dest = rtMatch ? rtMatch[1] : '/fan/';

  if (!code) {
    msg('No ?code found. Redirecting…');
    setTimeout(()=>location.replace(dest), 300);
    return;
  }

  // PKCE verifier we stashed before redirect
  const verifier = sessionStorage.getItem('pkce_verifier') || '';

  // Build token request — redirect_uri MUST MATCH exactly what was used in /authorize
  const body = new URLSearchParams({
    grant_type: 'authorization_code',
    client_id:  String(cfg.clientId || ''),
    redirect_uri: EXPECTED_REDIRECT,
    code_verifier: verifier,
    code
  });

  try {
    const res = await fetch(`${domain}/oauth2/token`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: body.toString()
    });
    const tok = await res.json();

    if (!res.ok || !tok.id_token) {
      console.error('Token exchange failed:', tok);
      msg('Sign-in failed. Please try again.');
      return;
    }

    // Store tokens in sessionStorage; mirror id_token to localStorage for role-aware nav
    sessionStorage.setItem('id_token', tok.id_token);
    if (tok.access_token)  sessionStorage.setItem('access_token', tok.access_token);
    if (tok.refresh_token) sessionStorage.setItem('refresh_token', tok.refresh_token);
    try { localStorage.setItem('sa_id_token', tok.id_token); } catch {}

    // Clean scratch values
    sessionStorage.removeItem('pkce_verifier');

    // Bounce to the intended tab (history.replace to keep it tidy)
    const u = new URL(dest, location.origin);
    history.replaceState(null,'', u);
    location.reload();
  } catch (e) {
    console.error(e);
    msg('Problem completing sign-in. See console.');
  }
})();
</script>
</body>
</html>
