{
  "version": 3,
  "sources": ["../../lambda/prime/episode-assembler.ts"],
  "sourcesContent": ["// lambda/prime/episode-assembler.ts\r\n\r\n/**\r\n * Episode Assembler Lambda\r\n *\r\n * This is a minimal stub used by PrimeStudiosStack to assemble a full\r\n * episode structure from modular components (invite, envelope, closet, etc).\r\n *\r\n * For now it just echoes inputs and ensures the Step Functions workflow\r\n * has something predictable to work with. You can expand this later to:\r\n * - Fetch component JSON from S3/DynamoDB\r\n * - Validate against JSON Schemas\r\n * - Build a full episode graph with branches, polls, etc.\r\n */\r\n\r\nexport interface EpisodeComponentRef {\r\n  type:\r\n    | \"INVITE\"\r\n    | \"ENVELOPE\"\r\n    | \"CLOSET\"\r\n    | \"OUTFIT\"\r\n    | \"DIALOGUE\"\r\n    | \"SIDE_QUEST\"\r\n    | \"COINS\"\r\n    | \"LOCATION\"\r\n    | \"PHOTOSHOOT\"\r\n    | string;\r\n  id: string; // component id / key (e.g. S3 key or DDB pk)\r\n}\r\n\r\nexport interface AssembleEpisodeInput {\r\n  episodeId?: string;\r\n  seasonId?: string;\r\n  showId?: string;\r\n\r\n  // Ordered list of modular components to stitch together\r\n  components?: EpisodeComponentRef[];\r\n\r\n  // Free-form metadata for now (rating, tags, etc)\r\n  metadata?: Record<string, unknown>;\r\n\r\n  // Who is running this (for audit)\r\n  requestedBy?: {\r\n    userId?: string;\r\n    role?: string;\r\n  };\r\n}\r\n\r\nexport interface EpisodeNode {\r\n  id: string;\r\n  kind: string;\r\n  ref?: EpisodeComponentRef;\r\n}\r\n\r\nexport interface AssembledEpisode {\r\n  episodeId: string;\r\n  seasonId?: string;\r\n  showId?: string;\r\n  status: \"DRAFT\" | \"READY_FOR_REVIEW\" | \"PUBLISHED\";\r\n\r\n  createdAt: string;\r\n  updatedAt: string;\r\n\r\n  // Very simple graph for now \u2014 linear sequence of nodes\r\n  nodes: EpisodeNode[];\r\n\r\n  metadata?: Record<string, unknown>;\r\n  requestedBy?: AssembleEpisodeInput[\"requestedBy\"];\r\n}\r\n\r\n/**\r\n * Generic handler so it works both from:\r\n * - Step Functions Task state\r\n * - Direct Lambda test events\r\n */\r\nexport const handler = async (\r\n  event: AssembleEpisodeInput,\r\n): Promise<AssembledEpisode> => {\r\n  const now = new Date().toISOString();\r\n\r\n  const episodeId =\r\n    event.episodeId ?? `ep-${Math.random().toString(36).slice(2, 10)}`;\r\n\r\n  const components = event.components ?? [];\r\n\r\n  const nodes: EpisodeNode[] = components.map((ref, idx) => ({\r\n    id: `${episodeId}-node-${idx}`,\r\n    kind: ref.type,\r\n    ref,\r\n  }));\r\n\r\n  const assembled: AssembledEpisode = {\r\n    episodeId,\r\n    seasonId: event.seasonId,\r\n    showId: event.showId,\r\n    status: \"DRAFT\",\r\n    createdAt: now,\r\n    updatedAt: now,\r\n    nodes,\r\n    metadata: event.metadata ?? {},\r\n    requestedBy: event.requestedBy,\r\n  };\r\n\r\n  // For now, just log + return. Step Functions will pass this forward.\r\n  console.log(\"Assembled episode:\", JSON.stringify(assembled, null, 2));\r\n\r\n  return assembled;\r\n};\r\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GA2EO,IAAME,EAAU,MACrBE,GAC8B,CAC9B,IAAMC,EAAM,IAAI,KAAK,EAAE,YAAY,EAE7BC,EACJF,EAAM,WAAa,MAAM,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,EAAG,EAAE,CAAC,GAI5DG,GAFaH,EAAM,YAAc,CAAC,GAEA,IAAI,CAACI,EAAKC,KAAS,CACzD,GAAI,GAAGH,CAAS,SAASG,CAAG,GAC5B,KAAMD,EAAI,KACV,IAAAA,CACF,EAAE,EAEIE,EAA8B,CAClC,UAAAJ,EACA,SAAUF,EAAM,SAChB,OAAQA,EAAM,OACd,OAAQ,QACR,UAAWC,EACX,UAAWA,EACX,MAAAE,EACA,SAAUH,EAAM,UAAY,CAAC,EAC7B,YAAaA,EAAM,WACrB,EAGA,eAAQ,IAAI,qBAAsB,KAAK,UAAUM,EAAW,KAAM,CAAC,CAAC,EAE7DA,CACT",
  "names": ["episode_assembler_exports", "__export", "handler", "__toCommonJS", "event", "now", "episodeId", "nodes", "ref", "idx", "assembled"]
}
