# ===============================================
# ⚠️  AUTO-GENERATED FILE — DO NOT EDIT
#
# Generated by: scripts/build-schema.mjs
# Source: appsync/schema/*.graphql
# ===============================================

# -----------------------------------------------
# 00_scalars.graphql
# -----------------------------------------------

# ─────────────────────────────────────────
# Scalars (AppSync + common)
# ─────────────────────────────────────────

scalar AWSDateTime
scalar AWSDate
scalar AWSJSON

# -----------------------------------------------
# 01_directives.graphql
# -----------------------------------------------

# ─────────────────────────────────────────
# AppSync auth directives (used throughout schema)
# ─────────────────────────────────────────

directive @aws_cognito_user_pools on FIELD_DEFINITION | OBJECT
directive @aws_auth(cognito_groups: [String!]) on FIELD_DEFINITION | OBJECT

# -----------------------------------------------
# 10_root.graphql
# -----------------------------------------------

# ─────────────────────────────────────────
# Root operation shells ONLY
# (Domain modules must use: extend type Query / extend type Mutation)
# ─────────────────────────────────────────

type Query {
  _root: String
}

type Mutation {
  _root: String
}

# -----------------------------------------------
# 15_core.graphql
# -----------------------------------------------

# ─────────────────────────────────────────
# Core / Auth
# ─────────────────────────────────────────

type Me {
  id: ID!
  email: String!
  role: String!
  tier: String!
}

type RoleResult {
  userId: ID!
  role: String!
}

extend type Query {
  # Simple healthcheck (used by hello.graphql in site/src/graphql)
  hello: String

  # Current user basic info
  me: Me! @aws_cognito_user_pools
}

extend type Mutation {
  setUserRole(userId: ID!, role: String!): RoleResult!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])
}

# -----------------------------------------------
# 20_closet.graphql
# -----------------------------------------------

# ─────────────────────────────────────────
# Closet domain
# Owns: closet enums, types, inputs, bg change request types, comments, likes
# ─────────────────────────────────────────

# ─────────────────────────────────────────
# Enums
# ─────────────────────────────────────────

enum ClosetAudience {
  PUBLIC
  BESTIES
  EXCLUSIVE
}

enum ClosetVisibility {
  PRIVATE
  BESTIE
  PUBLIC
}

# Expanded to match values used by backend/workflows and to avoid
# AppSync "Invalid input for Enum 'ClosetStatus'" serialization errors.
enum ClosetStatus {
  DRAFT
  PENDING
  PENDING_PUBLISH
  APPROVED
  PUBLISHED
  REJECTED
  ARCHIVED
  FAILED
  EXPIRED
}

enum ClosetFeedSort {
  NEWEST
  MOST_LOVED
  LALAS_PICK
  MY_FAVES
}

# ─────────────────────────────────────────
# Core types
# ─────────────────────────────────────────

type ClosetItem {
  id: ID!
  ownerId: ID
  ownerSub: ID
  title: String
  mediaKey: String
  rawMediaKey: String
  category: String
  subcategory: String
  colorTags: [String!]
  season: String
  vibes: String
  notes: String
  visibility: ClosetVisibility!
  affiliateUrl: String
  episodeIds: [ID!]
  status: ClosetStatus!
  audience: ClosetAudience
  pinned: Boolean
  favoriteCount: Int
  coinValue: Int
  backgroundStatus: String
  scheduledAt: AWSDateTime
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type ClosetConnection {
  items: [ClosetItem!]!
  nextToken: String
}

# ─────────────────────────────────────────
# Comments & Likes
# ─────────────────────────────────────────

type Comment {
  id: ID!
  itemId: ID!
  userId: ID!
  text: String!
  createdAt: AWSDateTime!
}

type CommentConnection {
  items: [Comment!]!
  nextToken: String
}

type Like {
  itemId: ID!
  userId: ID!
  createdAt: AWSDateTime!
}

type LikeConnection {
  items: [Like!]!
  nextToken: String
}

# ─────────────────────────────────────────
# Inputs
# ─────────────────────────────────────────

input CreateClosetItemInput {
  title: String
  mediaKey: String
  rawMediaKey: String
  category: String
  subcategory: String
  colorTags: [String!]
  season: String
  vibes: String
  notes: String
  visibility: ClosetVisibility
  affiliateUrl: String
  episodeIds: [ID!]
}

input UpdateClosetItemStoryInput {
  itemId: ID!
  storyId: ID
  storyPosition: Int
}

input CommentOnClosetItemInput {
  itemId: ID!
  text: String!
}

input BestieCreateClosetItemInput {
  title: String
  mediaKey: String
  rawMediaKey: String
  category: String
  subcategory: String
  colorTags: [String!]
  season: String
  vibes: String
  notes: String
  visibility: ClosetVisibility
  affiliateUrl: String
  episodeIds: [ID!]
}

input BestieUpdateClosetItemInput {
  title: String
  mediaKey: String
  rawMediaKey: String
  category: String
  subcategory: String
  colorTags: [String!]
  season: String
  vibes: String
  notes: String
  visibility: ClosetVisibility
  affiliateUrl: String
  episodeIds: [ID!]
}

input AdminCreateClosetItemInput {
  ownerId: ID
  title: String
  mediaKey: String
  rawMediaKey: String
  category: String
  subcategory: String
  colorTags: [String!]
  season: String
  vibes: String
  notes: String
  visibility: ClosetVisibility
  affiliateUrl: String
  episodeIds: [ID!]
  status: ClosetStatus
  audience: ClosetAudience
  pinned: Boolean
  coinValue: Int
  backgroundStatus: String
}

input AdminUpdateClosetItemInput {
  id: ID!
  ownerId: ID
  title: String
  mediaKey: String
  rawMediaKey: String
  category: String
  subcategory: String
  colorTags: [String!]
  season: String
  vibes: String
  notes: String
  visibility: ClosetVisibility
  affiliateUrl: String
  episodeIds: [ID!]
  status: ClosetStatus
  audience: ClosetAudience
  pinned: Boolean
  coinValue: Int
  backgroundStatus: String
  scheduledAt: AWSDateTime
}

# ─────────────────────────────────────────
# Query operations
# ─────────────────────────────────────────

extend type Query {
  myCloset(limit: Int, nextToken: String): ClosetConnection!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])

  myWishlist(limit: Int, nextToken: String): ClosetConnection!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])

  bestieClosetItems(limit: Int, nextToken: String): ClosetConnection!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])

  closetItemComments(itemId: ID!, limit: Int, nextToken: String): CommentConnection!
    @aws_cognito_user_pools

  adminClosetItemLikes(itemId: ID!, limit: Int, nextToken: String): LikeConnection!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  adminClosetItemComments(itemId: ID!, limit: Int, nextToken: String): CommentConnection!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  adminListPending(limit: Int, nextToken: String): ClosetConnection!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  adminListClosetItems(status: ClosetStatus, limit: Int, nextToken: String): ClosetConnection!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  adminListBestieClosetItems(status: ClosetStatus, limit: Int, nextToken: String): ClosetConnection!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  closetFeed(sort: ClosetFeedSort, limit: Int, nextToken: String): ClosetConnection!
    @aws_cognito_user_pools

  pinnedClosetItems: [ClosetItem!]!
    @aws_cognito_user_pools
}

# ─────────────────────────────────────────
# Mutation operations
# ─────────────────────────────────────────

extend type Mutation {
  createClosetItem(input: CreateClosetItemInput!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])

  requestClosetApproval(itemId: ID!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])

  updateClosetMediaKey(itemId: ID!, mediaKey: String!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])

  updateClosetItemStory(input: UpdateClosetItemStoryInput!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])

  likeClosetItem(itemId: ID!): ClosetItem!
    @aws_cognito_user_pools

  toggleFavoriteClosetItem(id: ID!, favoriteOn: Boolean): ClosetItem!
    @aws_cognito_user_pools

  commentOnClosetItem(input: CommentOnClosetItemInput!): Comment!
    @aws_cognito_user_pools

  bestieCreateClosetItem(input: BestieCreateClosetItemInput!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])

  bestieUpdateClosetItem(id: ID!, input: BestieUpdateClosetItemInput!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])

  bestieDeleteClosetItem(id: ID!): Boolean!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])

  adminCreateClosetItem(input: AdminCreateClosetItemInput!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  adminApproveItem(closetItemId: ID!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  adminRejectItem(closetItemId: ID!, reason: String): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  adminPublishClosetItem(closetItemId: ID!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  adminSetClosetAudience(closetItemId: ID!, audience: ClosetAudience!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  adminUpdateClosetItem(input: AdminUpdateClosetItemInput!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  # ─────────────────────────────────────────
  # ✅ Added to match ApiStack resolvers
  # ─────────────────────────────────────────

  pinHighlight(id: ID!, pinned: Boolean): ClosetItem!
    @aws_cognito_user_pools

  toggleWishlistItem(id: ID!, wishlistOn: Boolean): ClosetItem!
    @aws_cognito_user_pools

  addClosetItemToCommunityFeed(id: ID!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  removeClosetItemFromCommunityFeed(id: ID!): ClosetItem!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  shareClosetItemToPinterest(id: ID!): AWSJSON!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])
}

# -----------------------------------------------
# 25_bg-change.graphql
# -----------------------------------------------

"""
Background Change System
Allows creators to request and manage background changes for closet items.
"""

type BackgroundChangeRequest {
  id: ID!
  closetItemId: ID!
  userId: ID!
  creatorId: ID!
  originalS3Key: String!
  requestedBackground: String!
  status: BackgroundChangeStatus!
  processedS3Key: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  notes: String
}

enum BackgroundChangeStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSING
  COMPLETED
}

input BgChangeRequestInput {
  itemId: ID!
  newBackgroundKey: String!
  notes: String
}

type BgChangeRequestResult {
  ok: Boolean!
  requestId: ID
}

extend type Query {
  """
  Get background change requests for a closet item
  """
  closetItemBackgroundChanges(closetItemId: ID!): [BackgroundChangeRequest!]!

  """
  Get user's pending background change requests
  """
  myBackgroundChangeRequests: [BackgroundChangeRequest!]!

  """
  Admin: List all pending background change requests
  """
  adminListBackgroundChangeRequests(
    status: BackgroundChangeStatus
    limit: Int
    nextToken: String
  ): BackgroundChangeRequestConnection!
}

extend type Mutation {
  """
  Request a background change for a closet item
  """
  requestClosetBackgroundChangeExtended(
    closetItemId: ID!
    requestedBackground: String!
    notes: String
  ): BackgroundChangeRequest!

  """
  Admin: Approve a background change request
  """
  adminApproveBackgroundChange(
    requestId: ID!
  ): BackgroundChangeRequest!

  """
  Admin: Reject a background change request
  """
  adminRejectBackgroundChange(
    requestId: ID!
    reason: String!
  ): BackgroundChangeRequest!
}

type BackgroundChangeRequestConnection {
  items: [BackgroundChangeRequest!]!
  nextToken: String
}

# -----------------------------------------------
# 30_bestie.graphql
# -----------------------------------------------

# ─────────────────────────────────────────
# Bestie workflow + membership types
# ─────────────────────────────────────────

type BestieStatus {
  userId: ID!
  isBestie: Boolean!
  tier: String
  renewsAt: AWSDateTime
  trialActive: Boolean
  trialEndsAt: AWSDateTime
}

type BestieCheckoutSession {
  checkoutUrl: String!
}

extend type Mutation {
  """
  Bestie workflow: request a background swap for a closet item.
  """
  requestClosetBackgroundChange(input: BgChangeRequestInput!): BgChangeRequestResult!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])
}

# -----------------------------------------------
# 40_stories.graphql
# -----------------------------------------------

type BestieStory {
  id: ID!
  title: String!
  body: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime
  status: BestieStoryStatus!
  episodeId: ID
  closetItemIds: [ID!]
  mediaKeys: [String!]
}

enum BestieStoryStatus {
  DRAFT
  SCHEDULED
  PUBLISHED
  ARCHIVED
}

type BestieStoryConnection {
  items: [BestieStory!]!
  nextToken: String
}

type Story {
  id: ID!
  ownerId: ID!
  title: String
  status: String
  createdAt: AWSDateTime
  publishedAt: AWSDateTime
}

input CreateStoryInput {
  title: String!
  closetItemIds: [ID!]
}

extend type Query {
  stories(limit: Int, nextToken: String): BestieStoryConnection
    @aws_cognito_user_pools

  myStories(limit: Int, nextToken: String): BestieStoryConnection
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])
}

extend type Mutation {
  createStory(input: CreateStoryInput!): Story!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])

  publishStory(storyId: ID!): Story!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["BESTIE", "CREATOR", "COLLAB", "ADMIN", "PRIME"])
}

# -----------------------------------------------
# 44_music.graphql
# -----------------------------------------------

"""
Music System
Lala's music career, studio sessions, music videos, and era arcs.
"""

type MusicEra {
  id: ID!
  name: String!
  description: String!
  aesthetic: String!
  releaseDate: AWSDateTime!
  songs: [Song!]!
  musicVideos: [MusicVideo!]!
  relatedOutfits: [ClosetItem!]
  storyArcs: [String!]
  status: ReleaseStatus!
}

type Song {
  id: ID!
  title: String!
  eraId: ID!
  inspirationStory: String!
  lyrics: String
  spotifyUrl: String
  appleMusicUrl: String
  audioUrl: String!
  duration: Int!
  conflict: String
  studio: StudioSession!
  createdAt: AWSDateTime!
}

type MusicVideo {
  id: ID!
  songId: ID!
  title: String!
  description: String!
  s3Key: String!
  thumbnailKey: String
  duration: Int!
  shoppableItems: [ShoppableItem!]
  behindTheScenes: [BTS!]
  releaseDate: AWSDateTime!
  status: ReleaseStatus!
}

type StudioSession {
  id: ID!
  songId: ID!
  producer: String!
  engineerNotes: String!
  recordedAt: AWSDateTime!
  studio: String!
  s3RecordingKey: String
  dramaNotes: String
}

type BTS {
  id: ID!
  videoId: ID!
  thumbnailKey: String!
  title: String!
  description: String!
  s3Key: String!
}

enum ReleaseStatus {
  IN_PROGRESS
  TEASER_RELEASED
  RELEASED
  ARCHIVED
}

extend type Query {
  """
  Get all music eras
  """
  musicEras: [MusicEra!]!

  """
  Get a specific music era
  """
  musicEra(id: ID!): MusicEra

  """
  Get songs from an era
  """
  eraSongs(eraId: ID!): [Song!]!

  """
  Get music videos for a song
  """
  songMusicVideos(songId: ID!): [MusicVideo!]!

  """
  Get music video details (with shoppable items)
  """
  musicVideo(id: ID!): MusicVideo
}

extend type Mutation {
  """
  Admin: Create a new music era
  """
  adminCreateMusicEra(
    name: String!
    description: String!
    aesthetic: String!
    releaseDate: AWSDateTime!
  ): MusicEra!

  """
  Admin: Add a song to an era
  """
  adminCreateSong(
    eraId: ID!
    title: String!
    inspirationStory: String!
    spotifyUrl: String
    audioUrl: String!
  ): Song!

  """
  Admin: Release a music video
  """
  adminCreateMusicVideo(
    songId: ID!
    title: String!
    s3Key: String!
  ): MusicVideo!
}

# -----------------------------------------------
# 45_shopping.graphql
# -----------------------------------------------

"""
Shopping & Affiliate System
Powers "Shop Lala's Look" and exact item finder across all surfaces.
"""

type ShoppableItem {
  id: ID!
  closetItemId: ID
  musicVideoId: ID
  episodeId: ID
  brand: String!
  name: String!
  category: String!
  sku: String!
  imageUrl: String!
  price: Float!
  affiliateLinks: [AffiliateLink!]!
  alternativeProducts: [ShoppableItem!]
  lastSeenInScene: AWSDateTime!
  likeCount: Int!
}

type AffiliateLink {
  id: ID!
  retailer: String!
  url: String!
  commissionRate: Float!
  isActive: Boolean!
}

type ExactMatchResult {
  item: ShoppableItem!
  confidence: Float!
  matchType: String!
  source: String!
}

type ShoppingCart {
  id: ID!
  userId: ID!
  items: [ShoppableItem!]!
  total: Float!
  affiliateCredit: Float!
}

extend type Query {
  """
  Search for exact item match
  """
  findExactItem(
    brandName: String!
    itemName: String!
    category: String
  ): [ExactMatchResult!]!

  """
  Get shoppable items from a scene
  """
  sceneShoppableItems(sceneId: ID!): [ShoppableItem!]!

  """
  Get shoppable items from a music video
  """
  videoShoppableItems(videoId: ID!): [ShoppableItem!]!

  """
  Get user's shopping cart
  """
  myShoppingCart: ShoppingCart
}

extend type Mutation {
  """
  Add item to shopping cart
  """
  addToCart(itemId: ID!): ShoppingCart!

  """
  Remove item from shopping cart
  """
  removeFromCart(itemId: ID!): ShoppingCart!

  """
  Admin: Create shoppable item
  """
  adminCreateShoppableItem(
    brand: String!
    name: String!
    category: String!
    sku: String!
    imageUrl: String!
    price: Float!
  ): ShoppableItem!

  """
  Admin: Add affiliate link
  """
  adminAddAffiliateLink(
    itemId: ID!
    retailer: String!
    url: String!
    commissionRate: Float!
  ): AffiliateLink!
}

# -----------------------------------------------
# 46_prime-tea-report.graphql
# -----------------------------------------------

"""
Prime Tea Report System
Generates daily/weekly gossip reports about Lala & The Crew's drama, relationships, and hot takes.
Exclusive content for PRIME members.
"""

type TeaReport {
  id: ID!
  reportId: String!
  generatedAt: AWSDateTime!
  period: TeaPeriod!
  headline: String!
  summary: String!
  teaItems: [TeaItem!]!
  dramaMeter: Int!
  relationshipUpdates: [RelationshipStatus!]!
  hotTakes: [HotTake!]!
  viewCount: Int!
  shareCount: Int!
}

type TeaItem {
  id: ID!
  reportId: ID!
  title: String!
  description: String!
  teaLevel: Int!
  category: TeaCategory!
  characters: [String!]!
  relatedEpisode: String
  relatedMusic: String
  timestamp: AWSDateTime!
}

enum TeaCategory {
  ROMANCE
  FRIENDSHIP
  CREATIVE_TENSION
  FAN_DRAMA
  BEHIND_THE_SCENES
  TOUR_LIFE
  MUSIC_BEEF
  FASHION_TAKE
}

enum TeaPeriod {
  DAILY
  WEEKLY
  MONTHLY
}

type RelationshipStatus {
  character1: String!
  character2: String!
  status: String!
  confidence: Float!
  lastUpdated: AWSDateTime!
}

type HotTake {
  id: ID!
  author: String!
  content: String!
  sentiment: String!
  reactionCount: Int!
  timestamp: AWSDateTime!
}

type TeaReportConnection {
  items: [TeaReport!]!
  nextToken: String
}

extend type Query {
  """
  Get the latest Prime Tea Report
  """
  latestTeaReport: TeaReport @aws_cognito_user_pools

  """
  Get historical Tea Reports
  """
  teaReportHistory(
    period: TeaPeriod
    limit: Int
    nextToken: String
  ): TeaReportConnection! @aws_cognito_user_pools

  """
  Get drama details for a specific character
  """
  characterDrama(characterName: String!): [TeaItem!]! @aws_cognito_user_pools

  """
  Get relationship status between two characters
  """
  relationshipStatus(
    character1: String!
    character2: String!
  ): RelationshipStatus @aws_cognito_user_pools
}

extend type Mutation {
  """
  Admin: Generate a new Tea Report
  """
  adminGenerateTeaReport(
    period: TeaPeriod!
    sourceEpisodes: [String!]
    sourceMusic: [String!]
  ): TeaReport!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  """
  Admin: Add a hot take to a report
  """
  adminAddHotTake(
    reportId: ID!
    authorCharacter: String!
    content: String!
  ): HotTake!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  """
  Admin: Update relationship status
  """
  adminUpdateRelationshipStatus(
    character1: String!
    character2: String!
    status: String!
  ): RelationshipStatus!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])
}

# -----------------------------------------------
# 47_prime-magazine.graphql
# -----------------------------------------------

"""
Prime Magazine System
Premium digital magazine with exclusive editorials, photoshoots, and behind-the-scenes content.
Only accessible to PRIME members.
"""

type PrimeMagazine {
  id: ID!
  issueNumber: Int!
  title: String!
  theme: String!
  coverImageKey: String!
  coverStory: String!
  publishedAt: AWSDateTime!
  articles: [Article!]!
  exclusiveContent: [ExclusiveFeature!]!
  fashionEditorial: FashionEditorial
  musicFeature: MusicFeature
  viewCount: Int!
  likeCount: Int!
  status: MagazineStatus!
}

type Article {
  id: ID!
  magazineId: ID!
  title: String!
  author: String!
  category: ArticleCategory!
  content: String!
  featuredImages: [String!]!
  wordCount: Int!
  readTime: Int!
  createdAt: AWSDateTime!
}

enum ArticleCategory {
  EDITORIAL
  INTERVIEW
  BEHIND_THE_SCENES
  LIFESTYLE
  WELLNESS
  BUSINESS
  CREATOR_SPOTLIGHT
}

type ExclusiveFeature {
  id: ID!
  magazineId: ID!
  title: String!
  description: String!
  mediaFiles: [MediaFile!]!
  exclusivityLevel: String!
  viewsCount: Int!
}

type MediaFile {
  id: ID!
  featureId: ID!
  type: MediaType!
  s3Key: String!
  thumbnailKey: String
  duration: Int
  title: String!
}

enum MediaType {
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
}

type FashionEditorial {
  id: ID!
  magazineId: ID!
  title: String!
  description: String!
  photographyCredit: String!
  stylist: String!
  looks: [EditorialLook!]!
  behindTheScenes: [String!]
}

type EditorialLook {
  id: ID!
  editorialId: ID!
  name: String!
  description: String!
  imageKey: String!
  items: [ShoppableItem!]!
  inspirationStory: String
}

type MusicFeature {
  id: ID!
  magazineId: ID!
  title: String!
  featuredArtist: String!
  eraFocus: String
  songs: [Song!]!
  producerInterview: String
  studio: StudioSession
}

enum MagazineStatus {
  DRAFT
  SCHEDULED
  PUBLISHED
  ARCHIVED
}

type PrimeMagazineConnection {
  items: [PrimeMagazine!]!
  nextToken: String
}

extend type Query {
  """
  Get the current/latest Prime Magazine issue
  """
  currentPrimeMagazine: PrimeMagazine @aws_cognito_user_pools

  """
  Get all published Prime Magazine issues
  """
  primeMagazineArchive(
    limit: Int
    nextToken: String
  ): PrimeMagazineConnection! @aws_cognito_user_pools

  """
  Get a specific magazine issue
  """
  primeMagazine(issueNumber: Int!): PrimeMagazine @aws_cognito_user_pools

  """
  Get articles from a magazine
  """
  magazineArticles(
    magazineId: ID!
    category: ArticleCategory
  ): [Article!]! @aws_cognito_user_pools
}

extend type Mutation {
  """
  Admin: Create a new magazine issue
  """
  adminCreateMagazineIssue(
    issueNumber: Int!
    title: String!
    theme: String!
    coverImageKey: String!
  ): PrimeMagazine!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  """
  Admin: Add article to magazine
  """
  adminAddArticle(
    magazineId: ID!
    title: String!
    author: String!
    category: ArticleCategory!
    content: String!
  ): Article!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  """
  Admin: Create fashion editorial
  """
  adminCreateFashionEditorial(
    magazineId: ID!
    title: String!
    photographyCredit: String!
    stylist: String!
  ): FashionEditorial!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  """
  Admin: Publish magazine issue
  """
  adminPublishMagazine(
    magazineId: ID!
  ): PrimeMagazine!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])
}

# -----------------------------------------------
# 48_creator-forecast.graphql
# -----------------------------------------------

"""
Creator Forecast & Predictive Model System (PCFM)
Forecasts creator growth, audience sentiment, and trend predictions.
Powered by analytics and machine learning insights.
"""

type CreatorForecast {
  id: ID!
  creatorId: ID!
  forecastId: String!
  generatedAt: AWSDateTime!
  forecastPeriod: ForecastPeriod!
  growthPrediction: GrowthMetrics!
  audienceSentiment: SentimentAnalysis!
  trendPredictions: [TrendPrediction!]!
  riskFactors: [RiskFactor!]!
  opportunities: [Opportunity!]!
  recommendations: [Recommendation!]!
  confidence: Float!
  lastUpdated: AWSDateTime!
}

type GrowthMetrics {
  currentFollowers: Int!
  projectedFollowers: Int!
  growthRate: Float!
  engagementRate: Float!
  projectedEngagementRate: Float!
  estRevenueImpact: Float!
}

type SentimentAnalysis {
  overallSentiment: String!
  positivePercent: Float!
  neutralPercent: Float!
  negativePercent: Float!
  sentimentTrend: String!
  keyTopics: [String!]!
  communityHealth: Int!
}

type TrendPrediction {
  id: ID!
  forecastId: ID!
  trendName: String!
  category: TrendCategory!
  probability: Float!
  peakTime: AWSDateTime
  relevance: String!
  actionItems: [String!]!
}

enum TrendCategory {
  MUSIC
  FASHION
  LIFESTYLE
  CONTENT_FORMAT
  PLATFORM_SHIFT
  AUDIENCE_DEMOGRAPHIC
  SOCIAL_BEHAVIOR
}

type RiskFactor {
  id: ID!
  forecastId: ID!
  riskName: String!
  severity: RiskLevel!
  probability: Float!
  potentialImpact: String!
  mitigationStrategy: String!
}

enum RiskLevel {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type Opportunity {
  id: ID!
  forecastId: ID!
  opportunityName: String!
  category: OpportunityCategory!
  estimatedValue: Float!
  timeWindow: String!
  actionItems: [String!]!
  difficulty: String!
}

enum OpportunityCategory {
  COLLABORATION
  SPONSORSHIP
  EXPANSION
  PRODUCT_LAUNCH
  CONTENT_PIVOT
  MONETIZATION
}

type Recommendation {
  id: ID!
  forecastId: ID!
  priority: Int!
  title: String!
  description: String!
  expectedOutcome: String!
  timeframe: String!
  resourcesNeeded: [String!]!
  successMetrics: [String!]!
}

type CreatorReport {
  id: ID!
  creatorId: ID!
  reportDate: AWSDateTime!
  analyticsSnapshot: AnalyticsMetrics!
  forecasts: [CreatorForecast!]!
  historicalComparison: HistoricalTrend!
  recommendations: [String!]!
}

type AnalyticsMetrics {
  followers: Int!
  followersThisWeek: Int!
  engagement: Float!
  engagementThisWeek: Float!
  contentPosted: Int!
  avgLikes: Float!
  avgComments: Float!
  avgShares: Float!
  topContentType: String!
  peakEngagementTime: String!
}

type HistoricalTrend {
  period: String!
  avgGrowth: Float!
  bestPerformingContent: String!
  worstPerformingContent: String!
  sentimentChange: Float!
}

type CreatorForecastConnection {
  items: [CreatorForecast!]!
  nextToken: String
}

extend type Query {
  """
  Get latest forecast for a creator
  """
  creatorLatestForecast(creatorId: ID!): CreatorForecast
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["CREATOR", "COLLAB", "ADMIN", "PRIME"])

  """
  Get forecast history for a creator
  """
  creatorForecastHistory(
    creatorId: ID!
    limit: Int
    nextToken: String
  ): CreatorForecastConnection!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["CREATOR", "COLLAB", "ADMIN", "PRIME"])

  """
  Get comprehensive creator report with analytics and forecasts
  """
  creatorReport(creatorId: ID!): CreatorReport
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["CREATOR", "COLLAB", "ADMIN", "PRIME"])

  """
  Get trend predictions for the platform
  """
  platformTrendPredictions: [TrendPrediction!]!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["CREATOR", "COLLAB", "ADMIN", "PRIME"])

  """
  Get growth recommendations for a creator
  """
  creatorGrowthRecommendations(creatorId: ID!): [Recommendation!]!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["CREATOR", "COLLAB", "ADMIN", "PRIME"])
}

extend type Mutation {
  """
  Admin: Generate creator forecast
  """
  adminGenerateCreatorForecast(
    creatorId: ID!
    forecastPeriod: ForecastPeriod!
  ): CreatorForecast!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  """
  Admin: Update analytics for forecast model
  """
  adminUpdateAnalyticsSnapshot(
    creatorId: ID!
    metrics: AnalyticsMetricsInput!
  ): AnalyticsMetrics!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])

  """
  Admin: Generate platform-wide trend predictions
  """
  adminGeneratePlatformTrends: [TrendPrediction!]!
    @aws_cognito_user_pools
    @aws_auth(cognito_groups: ["ADMIN", "PRIME"])
}

enum ForecastPeriod {
  WEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
}

input AnalyticsMetricsInput {
  followers: Int!
  engagement: Float!
  contentPosted: Int!
  avgLikes: Float!
  avgComments: Float!
  avgShares: Float!
}

# -----------------------------------------------
# 51_bestie-spotlight.graphql
# -----------------------------------------------

# Bestie Spotlight System
# Celebrates fan reactions, theories, and community engagement
# Cross-platform promotion of top fans and theories

enum ReactionType {
  LOVE
  FIRE
  SHOCKED
  CRYING
  LAUGHING
  TEA
}

enum TheoryCategory {
  DRAMA
  FASHION
  MUSIC
  LORE
  SHIP
  PREDICTION
}

type BestieReaction {
  id: ID!
  bestieId: ID!
  episodeId: ID!
  reactionType: ReactionType!
  comment: String
  timestamp: AWSDateTime!
  likes: Int!
}

type BestieTheory {
  id: ID!
  bestieId: ID!
  category: TheoryCategory!
  title: String!
  description: String!
  evidenceLinks: [String!]
  upvotes: Int!
  downvotes: Int!
  isFeatured: Boolean!
  featuredAt: AWSDateTime
  timestamp: AWSDateTime!
}

type BestieSpotlight {
  id: ID!
  bestieId: ID!
  bestieUsername: String!
  bestieAvatar: String
  reactionCount: Int!
  theoryCount: Int!
  topReactions: [BestieReaction!]!
  topTheories: [BestieTheory!]!
  totalEngagement: Int!
  spotlightRank: Int!
  featuredOn: AWSDate
  platforms: [String!]
}

type BestieSpotlightPage {
  spots: [BestieSpotlight!]!
  nextToken: String
}

extend type Query {
  # Fetch all active Bestie Spotlights (with pagination)
  bestieSpotlights(limit: Int, nextToken: String): BestieSpotlightPage!

  # Fetch a specific Bestie's spotlight profile
  bestieSpotlight(bestieId: ID!): BestieSpotlight

  # Fetch theories for an episode
  episodeTheories(episodeId: ID!, limit: Int): [BestieTheory!]!

  # Fetch reactions for an episode
  episodeReactions(episodeId: ID!, limit: Int): [BestieReaction!]!

  # Search theories by category or keyword
  searchTheories(query: String!, category: TheoryCategory, limit: Int): [BestieTheory!]!

  # Top trending theories (24h)
  trendingTheories(limit: Int): [BestieTheory!]!

  # Top trending reactions (24h)
  trendingReactions(limit: Int): [BestieReaction!]!
}

extend type Mutation {
  # Add a reaction to an episode
  addReaction(episodeId: ID!, reactionType: ReactionType!, comment: String): BestieReaction!

  # Remove a reaction
  removeReaction(reactionId: ID!): Boolean!

  # Submit a theory
  submitTheory(
    category: TheoryCategory!
    title: String!
    description: String!
    evidenceLinks: [String!]
  ): BestieTheory!

  # Like/upvote a theory
  upvoteTheory(theoryId: ID!): BestieTheory!

  # Downvote a theory
  downvoteTheory(theoryId: ID!): BestieTheory!

  # Admin: Feature a theory for cross-platform promotion
  adminFeatureTheory(theoryId: ID!): BestieTheory!

  # Admin: Feature a Bestie for spotlight
  adminFeatureBestie(bestieId: ID!, platforms: [String!]): BestieSpotlight!

  # Admin: Generate weekly spotlight report
  adminGenerateSpotlightReport: BestieSpotlight!
}

