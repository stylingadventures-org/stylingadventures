<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Styling Adventures</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="/styles.css" />
  <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
  <link rel="alternate icon" href="/favicon.ico" />

  <!-- Small page-specific CSS (no inline style warnings) -->
  <style>
    /* Dropzone */
    #dropzone.dz {
      padding: 20px;
      border: 2px dashed #bbb;
      border-radius: 10px;
      transition: border-color .15s ease;
    }
    #dropzone.dz.dragover { border-color: #666; }

    /* Upload rows */
    .li-row { margin: 6px 0; }
    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .row strong { min-width:220px; word-break:break-all; }
    .row .size { min-width:90px; }
    .row .ctype { min-width:150px; }
    .row progress { width:220px; }
    .row .status { min-width:120px; }
    .ml-auto { margin-left:auto; }
    .hidden { display:none; }
    .error { color: #b00020; }
  </style>
</head>
<body class="sa-body">
  <h1>StylingAdventures</h1>

  <div class="actions">
    <a id="signin" href="#" class="sa-link">Sign in</a>
    <button id="signout" class="sa-btn sa-btn-outline ml-2">Sign out</button>
    <button id="signout-global" class="sa-btn sa-btn-outline ml-2">Sign out everywhere</button>
  </div>

  <h2>Status</h2>
  <div id="status" class="sa-card">Loading…</div>
  <button id="refresh-now" class="sa-btn mt-2" aria-label="Refresh tokens now">Refresh tokens now</button>

  <h3>Debug</h3>
  <pre id="dbg" class="sa-pre sa-muted"></pre>

  <!-- AppSync hello -->
  <h2>AppSync hello</h2>
  <div class="sa-card">
    <button id="btn-hello" class="sa-btn">Call { hello }</button>
    <span id="hello-out" class="ml-2 sa-muted" aria-live="polite"></span>
  </div>

  <!-- Uploads -->
  <h2>Uploads</h2>
  <div class="sa-card">
    <div class="form-row">
      <label for="upload-key" class="sa-label">Key prefix (optional)</label>
      <input id="upload-key" name="key" placeholder="e.g. photos/2025/" class="sa-input" />
    </div>

    <div class="form-row">
      <label for="upload-file" class="sa-label">Files</label>
      <input id="upload-file" name="file" type="file" multiple class="sa-input" />
    </div>

    <!-- Drag & Drop area -->
    <div id="dropzone" class="sa-card sa-muted dz">
      Drag & drop files here, or use the file picker above.
    </div>

    <button id="btn-upload" class="sa-btn mt-2" aria-label="Upload file(s) and list existing uploads">
      Upload selected files
    </button>

    <p id="uploads-msg" class="sa-muted mt-2" aria-live="polite"></p>

    <!-- Rendered list with per-item progress + delete -->
    <ul id="upload-list" class="sa-muted mt-2"></ul>
  </div>

  <script type="module">
    // ===== config / helpers =====
    const cfg = await fetch('/config.json?ts=' + Date.now(), { cache: 'no-store' })
      .then(r => r.json());

    // accept either "domain" or "hostedUiDomain"
    const hosted = cfg.domain || cfg.hostedUiDomain;
    if (!hosted) throw new Error('config.json missing "domain"/"hostedUiDomain"');
    const domain = `https://${hosted}.auth.${cfg.region}.amazoncognito.com`;

    // ✅ Compute redirect/logout URIs with hard normalization
    const ORIGIN = location.origin;
    const CB_INDEX = `${ORIGIN}/callback/index.html`;
    const CB_SLASH = `${ORIGIN}/callback/`;
    const allowedCallbacks = new Set([CB_INDEX, CB_SLASH]);
    const configuredRedirect = (cfg.redirectUri || '').trim();
    const redirectUri = allowedCallbacks.has(configuredRedirect) ? configuredRedirect : CB_INDEX;

    const LG_INDEX = `${ORIGIN}/logout/index.html`;
    const logoutRedirectUri = (cfg.logoutUri || LG_INDEX).trim() || LG_INDEX;

    const authorizeUrl = `${domain}/oauth2/authorize`;
    const logoutUrl = `${domain}/logout?client_id=${encodeURIComponent(cfg.clientId)}&logout_uri=${encodeURIComponent(logoutRedirectUri)}`;

    // accept "uploadsApiUrl" OR "uploadsUrl" OR "apiUrl"
    const apiBase = cfg.uploadsApiUrl || cfg.uploadsUrl || cfg.apiUrl;
    if (!apiBase) throw new Error('config.json missing "uploadsApiUrl"/"uploadsUrl"/"apiUrl"');
    const api = apiBase.replace(/\/+$/, '');

    const $ = s => document.querySelector(s);
    const enc = new TextEncoder();
    const MAX_MB = 50;
    const ALLOW_TYPES = ['text/plain','image/png','image/jpeg','image/gif','application/pdf','video/mp4'];
    const CONCURRENCY = 4;

    const MIME_BY_EXT = {
      png:'image/png', jpg:'image/jpeg', jpeg:'image/jpeg', gif:'image/gif',
      pdf:'application/pdf', txt:'text/plain', mp4:'video/mp4'
    };

    function base64Url(uint8){ return btoa(String.fromCharCode(...uint8)).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); }
    function randBytes(n){ const a=new Uint8Array(n); crypto.getRandomValues(a); return a; }
    function randomString(n=32){ return base64Url(randBytes(n)); }
    async function sha256(s){ const h=await crypto.subtle.digest('SHA-256', enc.encode(s)); return new Uint8Array(h); }

    const prettySize = b => {
      if (b == null) return '';
      const u = ['B','KB','MB','GB','TB']; let i = 0, n = Number(b);
      while (n >= 1024 && i < u.length-1){ n/=1024; i++; }
      return `${n.toFixed(n<10 && i>0 ? 1 : 0)} ${u[i]}`;
    };
    const inferTypeFromKey = (key) => {
      const m = key.toLowerCase().match(/\.([a-z0-9]+)$/); const ext = m?.[1] || '';
      return MIME_BY_EXT[ext] || 'application/octet-stream';
    };

    function sanitizePrefix(raw) {
      let s = (raw || '').trim();
      if (!s) return '';
      if (s.includes('..')) throw new Error('Prefix cannot contain ".."');
      s = s.replace(/^\/*/, '').replace(/\/+$/, '');
      s = s.replace(/[^A-Za-z0-9_\-\/]/g, '');
      if (!s) return '';
      return s + '/';
    }

    function toast(text, type='info'){
      const el = $('#uploads-msg');
      el.textContent = text;
      el.className = `sa-muted mt-2 ${type==='error' ? 'sa-error' : ''}`;
    }

    // ===== auth bits =====
    async function startLogin(){
      const verifier = randomString(64);
      sessionStorage.setItem('pkce_verifier', verifier);
      const challenge = base64Url(await sha256(verifier));
      const state = randomString(24);
      sessionStorage.setItem('oauth_state', state);
      const url = new URL(authorizeUrl);
      url.searchParams.set('response_type','code');
      url.searchParams.set('client_id', cfg.clientId);
      url.searchParams.set('redirect_uri', redirectUri);
      url.searchParams.set('scope','openid email profile');
      url.searchParams.set('code_challenge', challenge);
      url.searchParams.set('code_challenge_method','S256');
      url.searchParams.set('state', state);
      console.debug('[auth] domain:', domain);
      console.debug('[auth] redirect_uri →', redirectUri);
      console.debug('[auth] authorize URL →', url.toString());
      location.assign(url.toString());
    }

    function signOutLocal(){ sessionStorage.clear(); render(); }

    async function signOutEverywhere(){
      try{
        const refresh = sessionStorage.getItem('refresh_token') || (JSON.parse(sessionStorage.getItem('tokens')||'{}').refresh_token);
        if (refresh){
          const body = new URLSearchParams({ token: refresh, token_type_hint:'refresh_token', client_id: cfg.clientId });
          await fetch(`${domain}/oauth2/revoke`, { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body }).catch(()=>{});
        }
      } finally {
        sessionStorage.clear();
        location.replace(logoutUrl);
      }
    }

    function parseJwt(t){ if(!t) return null; try{ return JSON.parse(atob(t.split('.')[1].replace(/-/g,'+').replace(/_/g,'/')));}catch{return null;} }
    function secondsLeft(id){ const p=parseJwt(id); return p?.exp ? Math.max(0, p.exp - Math.floor(Date.now()/1000)) : 0; }

    async function ensureFreshIdToken(minSeconds=60){
      let id = sessionStorage.getItem('id_token');
      if (!id) return null;
      if (secondsLeft(id) > minSeconds) return id;
      const { refreshTokens, scheduleRotation } = await import('/auth/refresh.js');
      const out = await refreshTokens({ domain, clientId: cfg.clientId });
      scheduleRotation(out, { domain, clientId: cfg.clientId });
      render();
      return out.id_token || sessionStorage.getItem('id_token');
    }

    function render(){
      const id = sessionStorage.getItem('id_token');
      $('#signin').style.display = id ? 'none' : 'inline';
      $('#signout').style.display = id ? 'inline-block' : 'none';
      $('#signout-global').style.display = id ? 'inline-block' : 'none';
      const left = secondsLeft(id);
      const mins = Math.floor(left/60);
      const secs = String(left%60).padStart(2,'0');
      $('#status').textContent = id
        ? `Signed in · token refreshes in ${mins}:${secs}`
        : 'You’re signed out. Click “Sign in” to start.';
      $('#dbg').textContent = id ? JSON.stringify(parseJwt(id) || {}, null, 2) : '';
    }

    async function callHello(){
      const id = await ensureFreshIdToken();
      if (!id){ alert('Please sign in first'); return; }
      const res = await fetch(cfg.appsyncUrl,{
        method:'POST',
        headers:{ 'Content-Type':'application/json', 'Authorization': id },
        body: JSON.stringify({ query: `query Hello { hello }` })
      });
      if (!res.ok) throw new Error(`AppSync ${res.status}: ${await res.text()}`);
      const json = await res.json();
      $('#hello-out').textContent = json.data?.hello ?? '(no data)';
    }

    function liRow(displayName, sizeText, typeText){
      const li = document.createElement('li');
      li.className = 'li-row';
      li.innerHTML = `
        <div class="row">
          <strong>${displayName}</strong>
          <span class="sa-muted size">${sizeText||''}</span>
          <span class="sa-muted ctype">${typeText||''}</span>
          <progress max="100" value="0" class="row-progress"></progress>
          <span class="sa-muted status"></span>
          <button class="sa-btn sa-btn-outline sa-sm delete ml-auto hidden" disabled>Delete</button>
        </div>
      `;
      return li;
    }

    async function listUploads(){
      const id = sessionStorage.getItem('id_token');
      if (!id) return;
      const res = await fetch(`${api}/list`, { headers:{ Authorization: id }});
      if (!res.ok) return;
      const data = await res.json();
      const items = Array.isArray(data) ? data : (data.items ?? data.keys ?? []);
      const ul = $('#upload-list');
      ul.innerHTML = '';

      items.forEach(rec => {
        const key = typeof rec === 'string' ? rec : rec.key;
        const sizeText = typeof rec === 'string' ? '' : prettySize(rec.size);
        const typeText = inferTypeFromKey(key);
        const li = liRow(key, sizeText, typeText);
        const prog = li.querySelector('.row-progress');
        const status = li.querySelector('.status');
        const delBtn = li.querySelector('.delete');

        if (prog instanceof HTMLElement) prog.style.display = 'none';
        if (status) status.textContent = '';

        if (delBtn instanceof HTMLButtonElement) {
          delBtn.classList.remove('hidden');
          delBtn.disabled = false;
          delBtn.addEventListener('click', async () => {
            if (!confirm(`Delete "${key}"?`)) return;
            const idTok = await ensureFreshIdToken();
            delBtn.disabled = true;
            const r = await fetch(`${api}/delete?key=${encodeURIComponent(key)}`, { method:'DELETE', headers:{ Authorization: idTok }});
            if (!r.ok){ alert(`Delete failed: ${r.status} ${await r.text()}`); delBtn.disabled = false; return; }
            li.remove();
          });
        }

        ul.appendChild(li);
      });
    }

    $('#signin').addEventListener('click', e => { e.preventDefault(); startLogin(); });
    $('#signout').addEventListener('click', e => { e.preventDefault(); signOutLocal(); });
    $('#signout-global').addEventListener('click', e => { e.preventDefault(); signOutEverywhere(); });
    $('#btn-hello')?.addEventListener('click', e => { e.preventDefault(); callHello().catch(err => $('#hello-out').textContent = `Error: ${err.message}`); });
    $('#btn-upload')?.addEventListener('click', e => { e.preventDefault(); startUpload().catch(err => alert(err.message)); });

    (function backfill(){
      if (!sessionStorage.getItem('tokens')){
        const id = sessionStorage.getItem('id_token');
        const at = sessionStorage.getItem('access_token');
        const rt = sessionStorage.getItem('refresh_token');
        if (id && at && rt) sessionStorage.setItem('tokens', JSON.stringify({ id_token:id, access_token:at, refresh_token:rt, expires_in:3600 }));
      }
    })();

    (async function ensureRotation(){
      const raw = sessionStorage.getItem('tokens'); if (!raw) return;
      const tokens = JSON.parse(raw);
      const { scheduleRotation } = await import('/auth/refresh.js');
      scheduleRotation(tokens, { domain, clientId: cfg.clientId });
    })();

    $('#refresh-now')?.addEventListener('click', async e => {
      e.preventDefault();
      const { refreshTokens, scheduleRotation } = await import('/auth/refresh.js');
      try{
        const out = await refreshTokens({ domain, clientId: cfg.clientId });
        scheduleRotation(out, { domain, clientId: cfg.clientId });
        render();
      }catch(err){ alert(`Refresh failed: ${err.message||err}`); }
    });

    render();
    setInterval(render, 1000);
    if (sessionStorage.getItem('id_token')) listUploads();
  </script>
</body>
</html>
