# ─────────────────────────────────────────────
# SCALARS
# ─────────────────────────────────────────────
scalar AWSDateTime
scalar AWSJSON

# ─────────────────────────────────────────────
# ROOT TYPES
# ─────────────────────────────────────────────

type Query {
  # Simple test
  hello: String!

  # Basic identity derived from Cognito JWT
  me: Me!

  # Closet (fan/bestie)
  myCloset: [ClosetItem!]!
  myWishlist: [ClosetItem!]!
  closetItemComments(closetItemId: ID!): [ClosetComment!]!

  # Admin closet views
  adminClosetItemLikes(closetItemId: ID!): [ClosetLike!]!
  adminClosetItemComments(closetItemId: ID!): [ClosetComment!]!
  adminListPending: [ClosetItem!]!

  # Paginated admin list used by Closet Library UI
  adminListClosetItems(
    status: ClosetStatus
    limit: Int
    nextToken: String
  ): ClosetItemConnection!

  # Fan-facing closet feed
  closetFeed(
    sort: ClosetFeedSort
    status: ClosetStatus
    ownerSub: String
  ): [ClosetItem!]!

  # Bestie / tiers
  meBestieStatus: BestieStatus!

  # Episodes early-access gate
  isEpisodeEarlyAccess(episodeId: ID!): Boolean!

  # Game: leaderboard & polls & profile
  topXP(limit: Int): [LeaderboardEntry!]!
  topCoins(limit: Int): [LeaderboardEntry!]!
  getPoll(id: ID!): Poll
  getMyProfile: GameProfile!
}

type Mutation {
  # Roles
  setUserRole(userId: ID!, role: UserRole!): UserRoleAssignment!

  # Closet (fan/bestie)
  createClosetItem(input: CreateClosetItemInput!): ClosetItem!
  requestClosetApproval(closetItemId: ID!): ClosetItem!
  updateClosetMediaKey(closetItemId: ID!, mediaKey: String!): ClosetItem!
  updateClosetItemStory(closetItemId: ID!, story: String!): ClosetItem!

  likeClosetItem(closetItemId: ID!): ClosetItem!
  commentOnClosetItem(closetItemId: ID!, text: String!): ClosetComment!
  pinHighlight(closetItemId: ID!, pinned: Boolean!): ClosetItem!
  toggleWishlistItem(closetItemId: ID!): ClosetItem!

  # Closet admin
  adminCreateClosetItem(input: AdminCreateClosetItemInput!): ClosetItem!
  adminApproveItem(closetItemId: ID!): ClosetItem!
  adminRejectItem(closetItemId: ID!, reason: String): ClosetItem!
  adminSetClosetAudience(
    closetItemId: ID!
    audience: ClosetAudience!
  ): ClosetItem!
  adminUpdateClosetItem(
    closetItemId: ID!
    input: AdminUpdateClosetItemInput!
  ): ClosetItem!

  # Hearts for fan closet feed
  # NOTE: made return type nullable to avoid AppSync "Cannot return null for non-nullable type 'ClosetItem'" errors
  toggleFavoriteClosetItem(id: ID!, favoriteOn: Boolean): ClosetItem

  # Bestie / tiers
  startBestieCheckout: BestieCheckoutSession!
  claimBestieTrial: BestieStatus!

  adminSetBestie(userId: ID!): BestieStatus!
  adminRevokeBestie(userId: ID!): BestieStatus!
  adminSetBestieByEmail(email: String!): BestieStatus!
  adminRevokeBestieByEmail(email: String!): BestieStatus!

  # Game
  logGameEvent(input: LogGameEventInput!): GameEventResult!
  awardCoins(userId: ID!, amount: Int!): GameProfile!

  createPoll(input: CreatePollInput!): Poll!
  votePoll(pollId: ID!, optionId: ID!): Poll!

  grantBadge(userId: ID!, badgeId: ID!): GameProfile!
  setDisplayName(name: String!): GameProfile!
  updateProfile(input: UpdateProfileInput!): GameProfile!
}

# ─────────────────────────────────────────────
# IDENTITY / USER
# ─────────────────────────────────────────────

type Me {
  id: ID!
  email: String
  role: String
  tier: String
}

enum UserRole {
  FAN
  BESTIE
  ADMIN
}

type UserRoleAssignment {
  userId: ID!
  role: UserRole!
}

# ─────────────────────────────────────────────
# CLOSET DOMAIN
# ─────────────────────────────────────────────

# Audience enum – include all values the UI might use
enum ClosetAudience {
  PRIVATE
  FOLLOWERS
  PUBLIC
  BESTIE
  EXCLUSIVE
  ADMIN_ONLY
  HIDDEN
}

# Status enum – for item.status + filters
enum ClosetStatus {
  DRAFT
  PENDING
  APPROVED
  REJECTED
  PUBLISHED
  ARCHIVED
}

# Sorting enum for fan closet feed
enum ClosetFeedSort {
  NEWEST
  MOST_LOVED
}

# Connection wrapper for adminListClosetItems
type ClosetItemConnection {
  items: [ClosetItem!]!
  nextToken: String
}

type ClosetItem {
  id: ID!
  ownerSub: ID
  userId: ID
  title: String
  description: String
  story: String
  status: ClosetStatus
  audience: ClosetAudience
  mediaKey: String
  rawMediaKey: String

  # Categorization
  category: String
  subcategory: String

  # Extra admin-upload metadata
  season: String
  vibes: String

  # Admin metadata (e.g. rejection reason)
  reason: String

  # Lala's pick flag
  pinned: Boolean

  # Computed flags/metrics
  isInWishlist: Boolean!
  isPinnedHighlight: Boolean!
  likesCount: Int!
  commentsCount: Int!

  # Fan “heart” data
  favoriteCount: Int
  viewerHasFaved: Boolean

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input CreateClosetItemInput {
  # existing fan-side fields
  title: String
  description: String
  story: String
  audience: ClosetAudience

  # media keys
  mediaKey: String
  rawMediaKey: String

  # categorization
  category: String
  subcategory: String
}

input AdminCreateClosetItemInput {
  # optional: allow admins to create on behalf of another user if needed
  ownerId: ID

  title: String
  description: String
  story: String

  # if a cutout already exists we could pass mediaKey,
  # but for the new upload flow we send rawMediaKey
  mediaKey: String
  rawMediaKey: String

  audience: ClosetAudience

  # upload-studio metadata
  season: String
  vibes: String

  # categorization
  category: String
  subcategory: String
}

input AdminUpdateClosetItemInput {
  title: String
  category: String
  subcategory: String
  audience: ClosetAudience
}

type ClosetComment {
  id: ID!
  closetItemId: ID!
  authorId: ID!
  text: String!
  createdAt: AWSDateTime!
}

type ClosetLike {
  closetItemId: ID!
  userId: ID!
  createdAt: AWSDateTime!
}

# ─────────────────────────────────────────────
# BESTIE / TIERS
# ─────────────────────────────────────────────

enum BestieTier {
  FREE
  PAID
}

type BestieStatus {
  userId: ID!
  isBestie: Boolean!
  tier: BestieTier!
  expiresAt: AWSDateTime
  activeSubscription: Boolean!
}

type BestieCheckoutSession {
  url: String!
}

# ─────────────────────────────────────────────
# EPISODES / EARLY ACCESS
# ─────────────────────────────────────────────

type EpisodeAccess {
  episodeId: ID!
  isEarlyAccess: Boolean!
}

# ─────────────────────────────────────────────
# GAME / PROFILE / LEADERBOARD / POLLS
# ─────────────────────────────────────────────

type LeaderboardEntry {
  userId: ID!
  displayName: String
  xp: Int!
  coins: Int!
  rank: Int!
}

type GameProfile {
  userId: ID!
  displayName: String
  xp: Int!
  coins: Int!
  badges: [Badge!]!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime
}

type Badge {
  id: ID!
  name: String!
  description: String
  earnedAt: AWSDateTime!
}

input UpdateProfileInput {
  displayName: String
}

input LogGameEventInput {
  type: String!
  episodeId: ID
  metadata: AWSJSON
}

type GameEventResult {
  success: Boolean!

  # Legacy fields (kept for backwards compatibility)
  newXP: Int
  newCoins: Int

  # Fields used by the current client
  xp: Int
  coins: Int
  lastEventAt: AWSDateTime
}

type Poll {
  id: ID!
  question: String!
  options: [PollOption!]!
  createdAt: AWSDateTime!
  closesAt: AWSDateTime
  totalVotes: Int!
}

type PollOption {
  id: ID!
  text: String!
  votes: Int!
}

input CreatePollInput {
  question: String!
  options: [String!]!
  closesAt: AWSDateTime
}
