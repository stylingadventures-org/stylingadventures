{
  "version": 3,
  "sources": ["../../lambda/closet/admin.ts"],
  "sourcesContent": ["// lambda/closet/admin.ts\r\n//\r\n// AppSync \"admin\" Lambda for closet moderation:\r\n//   - Query.adminListPending\r\n//   - Mutation.adminApproveItem\r\n//   - Mutation.adminRejectItem\r\n//   - Mutation.adminSetClosetAudience   <-- NEW\r\n//\r\n// NOTE: This file assumes your app table has primary keys\r\n//   pk  (string)\r\n//   sk  (string)\r\n// and that closet items can be uniquely located by \"id\" via a GSI or scan.\r\n// If your existing schema differs, only adjust the bits marked with\r\n//   // TODO(pk/sk lookup)\r\n// to use your real key layout.\r\n\r\nimport {\r\n  DynamoDBClient,\r\n  QueryCommand,\r\n  UpdateItemCommand,\r\n  GetItemCommand,\r\n  ScanCommand,\r\n} from \"@aws-sdk/client-dynamodb\";\r\nimport { unmarshall } from \"@aws-sdk/util-dynamodb\";\r\n\r\nconst ddb = new DynamoDBClient({});\r\nconst TABLE_NAME = process.env.APP_TABLE!;\r\n\r\ntype ClosetStatus = \"DRAFT\" | \"PENDING\" | \"APPROVED\" | \"REJECTED\" | \"PUBLISHED\";\r\ntype ClosetAudience = \"PUBLIC\" | \"BESTIE\" | \"EXCLUSIVE\";\r\n\r\ntype ClosetItem = {\r\n  id: string;\r\n  userId: string;\r\n  ownerSub: string;\r\n  status: ClosetStatus;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  mediaKey?: string | null;\r\n  title?: string | null;\r\n  reason?: string | null;\r\n  audience?: ClosetAudience | null;\r\n};\r\n\r\ntype AppSyncEvent = {\r\n  info: { fieldName: string; parentTypeName: string };\r\n  arguments: any;\r\n};\r\n\r\n// ---------- small helpers ----------\r\n\r\n// Map a DynamoDB record into the GraphQL ClosetItem type\r\nfunction mapClosetItem(raw: any): ClosetItem {\r\n  const it = unmarshall(raw) as any;\r\n  return {\r\n    id: String(it.id),\r\n    userId: String(it.userId ?? it.ownerSub ?? \"\"),\r\n    ownerSub: String(it.ownerSub ?? it.userId ?? \"\"),\r\n    status: (it.status ?? \"PENDING\") as ClosetStatus,\r\n    createdAt: String(it.createdAt),\r\n    updatedAt: String(it.updatedAt ?? it.createdAt),\r\n    mediaKey: it.mediaKey ?? null,\r\n    title: it.title ?? null,\r\n    reason: it.reason ?? null,\r\n    audience: (it.audience ?? \"PUBLIC\") as ClosetAudience,\r\n  };\r\n}\r\n\r\n// --- IMPORTANT: locate an item by id ---\r\n// This is the only part that really depends on your table layout.\r\n// The implementation below uses a Scan with a FilterExpression on \"id\",\r\n// which works for low volume and does NOT assume specific pk/sk.\r\n// If you already have a GSI for closet items, you can replace this with\r\n// a Query on that index for better efficiency.\r\nasync function findRawItemById(id: string) {\r\n  const resp = await ddb.send(\r\n    new ScanCommand({\r\n      TableName: TABLE_NAME,\r\n      FilterExpression: \"#id = :id AND #type = :type\",\r\n      ExpressionAttributeNames: {\r\n        \"#id\": \"id\",\r\n        \"#type\": \"entityType\",\r\n      },\r\n      ExpressionAttributeValues: {\r\n        \":id\": { S: id },\r\n        \":type\": { S: \"CLOSET_ITEM\" }, // <-- if you don't have entityType, drop this condition\r\n      },\r\n      Limit: 1,\r\n    }),\r\n  );\r\n\r\n  if (!resp.Items || resp.Items.length === 0) return null;\r\n  return resp.Items[0];\r\n}\r\n\r\n// For updates we need the primary key (pk, sk). We derive it from the\r\n// found item; if your schema uses different names, adjust here.\r\nfunction pkOf(raw: any) {\r\n  if (\"pk\" in raw && \"sk\" in raw) {\r\n    return { pk: raw.pk.S!, sk: raw.sk.S! };\r\n  }\r\n  throw new Error(\"Could not infer pk/sk for closet item\");\r\n}\r\n\r\n// ---------- resolvers ----------\r\n\r\nasync function adminListPending(): Promise<ClosetItem[]> {\r\n  // Generic, index-agnostic implementation using Scan by status.\r\n  // If you already have a GSI for status, swap this out for a Query.\r\n  const resp = await ddb.send(\r\n    new ScanCommand({\r\n      TableName: TABLE_NAME,\r\n      FilterExpression: \"#type = :type AND #status = :pending\",\r\n      ExpressionAttributeNames: {\r\n        \"#type\": \"entityType\",\r\n        \"#status\": \"status\",\r\n      },\r\n      ExpressionAttributeValues: {\r\n        \":type\": { S: \"CLOSET_ITEM\" },\r\n        \":pending\": { S: \"PENDING\" },\r\n      },\r\n    }),\r\n  );\r\n\r\n  return (resp.Items || []).map(mapClosetItem);\r\n}\r\n\r\nasync function adminApproveItem(args: {\r\n  id: string;\r\n}): Promise<ClosetItem | null> {\r\n  const base = await findRawItemById(args.id);\r\n  if (!base) return null;\r\n\r\n  const { pk, sk } = pkOf(base);\r\n  const now = new Date().toISOString();\r\n\r\n  const resp = await ddb.send(\r\n    new UpdateItemCommand({\r\n      TableName: TABLE_NAME,\r\n      Key: {\r\n        pk: { S: pk },\r\n        sk: { S: sk },\r\n      },\r\n      UpdateExpression:\r\n        \"SET #status = :approved, #updatedAt = :now REMOVE #reason\",\r\n      ExpressionAttributeNames: {\r\n        \"#status\": \"status\",\r\n        \"#updatedAt\": \"updatedAt\",\r\n        \"#reason\": \"reason\",\r\n      },\r\n      ExpressionAttributeValues: {\r\n        \":approved\": { S: \"APPROVED\" },\r\n        \":now\": { S: now },\r\n      },\r\n      ReturnValues: \"ALL_NEW\",\r\n    }),\r\n  );\r\n\r\n  return resp.Attributes ? mapClosetItem(resp.Attributes) : null;\r\n}\r\n\r\nasync function adminRejectItem(args: {\r\n  id: string;\r\n  reason?: string | null;\r\n}): Promise<ClosetItem | null> {\r\n  const base = await findRawItemById(args.id);\r\n  if (!base) return null;\r\n\r\n  const { pk, sk } = pkOf(base);\r\n  const now = new Date().toISOString();\r\n\r\n  const hasReason = !!args.reason && args.reason.trim().length > 0;\r\n\r\n  const resp = await ddb.send(\r\n    new UpdateItemCommand({\r\n      TableName: TABLE_NAME,\r\n      Key: {\r\n        pk: { S: pk },\r\n        sk: { S: sk },\r\n      },\r\n      UpdateExpression: hasReason\r\n        ? \"SET #status = :rejected, #updatedAt = :now, #reason = :reason\"\r\n        : \"SET #status = :rejected, #updatedAt = :now REMOVE #reason\",\r\n      ExpressionAttributeNames: {\r\n        \"#status\": \"status\",\r\n        \"#updatedAt\": \"updatedAt\",\r\n        \"#reason\": \"reason\",\r\n      },\r\n      ExpressionAttributeValues: {\r\n        \":rejected\": { S: \"REJECTED\" },\r\n        \":now\": { S: now },\r\n        ...(hasReason ? { \":reason\": { S: args.reason! } } : {}),\r\n      },\r\n      ReturnValues: \"ALL_NEW\",\r\n    }),\r\n  );\r\n\r\n  return resp.Attributes ? mapClosetItem(resp.Attributes) : null;\r\n}\r\n\r\n// NEW: set who can see an item once it\u2019s approved\r\nasync function adminSetClosetAudience(args: {\r\n  id: string;\r\n  audience: ClosetAudience;\r\n}): Promise<ClosetItem | null> {\r\n  const base = await findRawItemById(args.id);\r\n  if (!base) return null;\r\n\r\n  const { pk, sk } = pkOf(base);\r\n  const now = new Date().toISOString();\r\n\r\n  const resp = await ddb.send(\r\n    new UpdateItemCommand({\r\n      TableName: TABLE_NAME,\r\n      Key: {\r\n        pk: { S: pk },\r\n        sk: { S: sk },\r\n      },\r\n      UpdateExpression: \"SET #audience = :aud, #updatedAt = :now\",\r\n      ExpressionAttributeNames: {\r\n        \"#audience\": \"audience\",\r\n        \"#updatedAt\": \"updatedAt\",\r\n      },\r\n      ExpressionAttributeValues: {\r\n        \":aud\": { S: args.audience },\r\n        \":now\": { S: now },\r\n      },\r\n      ReturnValues: \"ALL_NEW\",\r\n    }),\r\n  );\r\n\r\n  return resp.Attributes ? mapClosetItem(resp.Attributes) : null;\r\n}\r\n\r\n// ---------- exported handler ----------\r\n\r\nexport const handler = async (event: AppSyncEvent) => {\r\n  const { fieldName, parentTypeName } = event.info;\r\n\r\n  if (parentTypeName === \"Query\") {\r\n    if (fieldName === \"adminListPending\") {\r\n      return adminListPending();\r\n    }\r\n  }\r\n\r\n  if (parentTypeName === \"Mutation\") {\r\n    if (fieldName === \"adminApproveItem\") {\r\n      return adminApproveItem(event.arguments);\r\n    }\r\n    if (fieldName === \"adminRejectItem\") {\r\n      return adminRejectItem(event.arguments);\r\n    }\r\n    if (fieldName === \"adminSetClosetAudience\") {\r\n      return adminSetClosetAudience(event.arguments);\r\n    }\r\n  }\r\n\r\n  throw new Error(\r\n    `Unknown field ${parentTypeName}.${fieldName} in ClosetAdminFn`,\r\n  );\r\n};\r\n"],
  "mappings": "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",
  "names": ["admin_exports", "__export", "handler", "__toCommonJS", "import_client_dynamodb", "import_util_dynamodb", "ddb", "TABLE_NAME", "mapClosetItem", "raw", "it", "findRawItemById", "id", "resp", "pkOf", "adminListPending", "adminApproveItem", "args", "base", "pk", "sk", "now", "adminRejectItem", "hasReason", "adminSetClosetAudience", "event", "fieldName", "parentTypeName"]
}
