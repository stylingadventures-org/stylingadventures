{
  "version": 3,
  "sources": ["../../lambda/internal/appsync-schema-ready.ts"],
  "sourcesContent": ["/* eslint-disable no-console */\r\nimport {\r\n  AppSyncClient,\r\n  GetIntrospectionSchemaCommand,\r\n  GetSchemaCreationStatusCommand,\r\n} from \"@aws-sdk/client-appsync\";\r\n\r\ntype CfnCustomResourceEvent = {\r\n  RequestType: \"Create\" | \"Update\" | \"Delete\";\r\n  PhysicalResourceId?: string;\r\n  ResourceProperties?: Record<string, any>;\r\n};\r\n\r\ntype HandlerResult = {\r\n  PhysicalResourceId: string;\r\n  Data?: Record<string, any>;\r\n};\r\n\r\nconst sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));\r\n\r\nfunction nowIso() {\r\n  return new Date().toISOString();\r\n}\r\n\r\nfunction log(...args: any[]) {\r\n  console.log(`[schema-ready] ${nowIso()}`, ...args);\r\n}\r\n\r\nfunction warn(...args: any[]) {\r\n  console.warn(`[schema-ready] ${nowIso()}`, ...args);\r\n}\r\n\r\nfunction err(...args: any[]) {\r\n  console.error(`[schema-ready] ${nowIso()}`, ...args);\r\n}\r\n\r\nfunction requiredString(v: any, name: string): string {\r\n  if (typeof v === \"string\" && v.trim().length > 0) return v.trim();\r\n  throw new Error(`Missing required \"${name}\" (got ${JSON.stringify(v)})`);\r\n}\r\n\r\nfunction parseNumber(v: any, fallback: number): number {\r\n  const n = Number(v);\r\n  return Number.isFinite(n) && n > 0 ? n : fallback;\r\n}\r\n\r\nfunction findMutationBlock(sdl: string): string | null {\r\n  // Keep it simple: grab \"type Mutation { ... }\" block if present\r\n  const m = sdl.match(/type\\s+Mutation\\s*\\{[\\s\\S]*?\\}/m);\r\n  return m ? m[0] : null;\r\n}\r\n\r\nfunction fieldExistsAnywhere(sdl: string, fieldName: string): boolean {\r\n  // word boundary match; avoids matching \"adminPublishClosetItemXYZ\"\r\n  const re = new RegExp(`\\\\b${escapeRegExp(fieldName)}\\\\b`);\r\n  return re.test(sdl);\r\n}\r\n\r\nfunction fieldExistsInMutation(sdl: string, fieldName: string): boolean {\r\n  const block = findMutationBlock(sdl);\r\n  if (!block) return false;\r\n  const re = new RegExp(`\\\\b${escapeRegExp(fieldName)}\\\\b`);\r\n  return re.test(block);\r\n}\r\n\r\nfunction escapeRegExp(s: string) {\r\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n\r\nasync function getSchemaStatus(client: AppSyncClient, apiId: string) {\r\n  const resp = await client.send(new GetSchemaCreationStatusCommand({ apiId }));\r\n  // status values typically: PROCESSING | SUCCESS | FAILED | NOT_APPLICABLE\r\n  return {\r\n    status: resp.status ?? \"UNKNOWN\",\r\n    details: resp.details ?? \"\",\r\n  };\r\n}\r\n\r\nasync function getIntrospectionSdl(client: AppSyncClient, apiId: string) {\r\n  const resp = await client.send(\r\n    new GetIntrospectionSchemaCommand({\r\n      apiId,\r\n      format: \"SDL\",\r\n    })\r\n  );\r\n\r\n  // Handle both shapes:\r\n  // - Some SDKs/handlers return base64 string\r\n  // - SDK v3 returns Uint8Array bytes\r\n  const raw = resp.schema;\r\n  if (!raw) return \"\";\r\n\r\n  const buf =\r\n    typeof raw === \"string\"\r\n      ? Buffer.from(raw, \"base64\")\r\n      : Buffer.from(raw as Uint8Array);\r\n\r\n  return buf.toString(\"utf8\");\r\n}\r\n\r\nasync function waitForSchemaSuccess(\r\n  client: AppSyncClient,\r\n  apiId: string,\r\n  maxAttempts: number,\r\n  delayMs: number\r\n) {\r\n  for (let i = 1; i <= maxAttempts; i++) {\r\n    const { status, details } = await getSchemaStatus(client, apiId);\r\n\r\n    log(`schema status attempt ${i}/${maxAttempts}: ${status} (${details})`);\r\n\r\n    if (status === \"SUCCESS\") return { status, details };\r\n    if (status === \"FAILED\") {\r\n      throw new Error(`Schema status FAILED: ${details || \"no details\"}`);\r\n    }\r\n\r\n    // PROCESSING / NOT_APPLICABLE / UNKNOWN -> keep waiting\r\n    await sleep(delayMs);\r\n  }\r\n\r\n  throw new Error(`Timed out waiting for schema to reach SUCCESS`);\r\n}\r\n\r\nasync function waitForFieldInIntrospection(\r\n  client: AppSyncClient,\r\n  apiId: string,\r\n  expectedField: string,\r\n  maxAttempts: number,\r\n  delayMs: number\r\n) {\r\n  let lastSdlLen = 0;\r\n  let lastMutationHasField = false;\r\n\r\n  for (let i = 1; i <= maxAttempts; i++) {\r\n    let sdl = \"\";\r\n    try {\r\n      sdl = await getIntrospectionSdl(client, apiId);\r\n    } catch (e: any) {\r\n      warn(`introspection attempt ${i}/${maxAttempts} error:`, e?.message ?? e);\r\n      await sleep(delayMs);\r\n      continue;\r\n    }\r\n\r\n    lastSdlLen = sdl.length;\r\n\r\n    const anywhere = fieldExistsAnywhere(sdl, expectedField);\r\n    const inMutation = fieldExistsInMutation(sdl, expectedField);\r\n    lastMutationHasField = inMutation;\r\n\r\n    log(\r\n      `introspection attempt ${i}/${maxAttempts}: sdlLen=${sdl.length} fieldAnywhere=${anywhere} fieldInMutation=${inMutation}`\r\n    );\r\n\r\n    // \u2705 DEBUG: Log the first 2000 chars of the SDL to see what we're getting\r\n    if (i === 1) {\r\n      log(\"SDL prefix (first 2000 chars):\", JSON.stringify(sdl.slice(0, 2000)));\r\n      const queryMatch = sdl.match(/extend type Query \\{[\\s\\S]*?\\}/);\r\n      if (queryMatch) {\r\n        log(\"Query block found:\", JSON.stringify(queryMatch[0]));\r\n      } else {\r\n        log(\"No 'extend type Query' block found\");\r\n      }\r\n    }\r\n\r\n    // If it's anywhere, we consider it \"ready\" to avoid false negatives\r\n    // (AppSync introspection can be eventually consistent / timing-sensitive).\r\n    if (anywhere) {\r\n      // Provide a tiny context snippet in logs for confidence\r\n      const idx = sdl.search(new RegExp(`\\\\b${escapeRegExp(expectedField)}\\\\b`));\r\n      if (idx >= 0) {\r\n        const start = Math.max(0, idx - 80);\r\n        const end = Math.min(sdl.length, idx + 120);\r\n        log(\"field context snippet:\", JSON.stringify(sdl.slice(start, end)));\r\n      }\r\n      return {\r\n        ok: true,\r\n        fieldAnywhere: true,\r\n        fieldInMutation: inMutation,\r\n        sdlLen: sdl.length,\r\n      };\r\n    }\r\n\r\n    // Backoff with small jitter\r\n    const jitter = Math.floor(Math.random() * Math.min(500, delayMs));\r\n    await sleep(delayMs + jitter);\r\n  }\r\n\r\n  return {\r\n    ok: false,\r\n    fieldAnywhere: false,\r\n    fieldInMutation: lastMutationHasField,\r\n    sdlLen: lastSdlLen,\r\n  };\r\n}\r\n\r\nexport async function handler(event: CfnCustomResourceEvent): Promise<HandlerResult> {\r\n  const props = event?.ResourceProperties ?? {};\r\n\r\n  // Allow either env vars or ResourceProperties\r\n  const apiId =\r\n    (process.env.APPSYNC_API_ID as string) ??\r\n    (process.env.API_ID as string) ??\r\n    props.apiId ??\r\n    props.ApiId;\r\n\r\n  const expectedField =\r\n    (process.env.EXPECTED_FIELD as string) ??\r\n    props.expectedField ??\r\n    props.ExpectedField;\r\n\r\n  const region =\r\n    (process.env.AWS_REGION as string) ??\r\n    (process.env.REGION as string) ??\r\n    props.region ??\r\n    props.Region;\r\n\r\n  const maxSchemaAttempts = parseNumber(\r\n    process.env.SCHEMA_STATUS_MAX_ATTEMPTS ?? props.schemaStatusMaxAttempts,\r\n    30\r\n  );\r\n  const schemaDelayMs = parseNumber(\r\n    process.env.SCHEMA_STATUS_DELAY_MS ?? props.schemaStatusDelayMs,\r\n    2000\r\n  );\r\n\r\n  const maxIntrospectionAttempts = parseNumber(\r\n    process.env.INTROSPECTION_MAX_ATTEMPTS ?? props.introspectionMaxAttempts,\r\n    40\r\n  );\r\n  const introspectionDelayMs = parseNumber(\r\n    process.env.INTROSPECTION_DELAY_MS ?? props.introspectionDelayMs,\r\n    2500\r\n  );\r\n\r\n  const physicalId =\r\n    event.PhysicalResourceId ??\r\n    `AppSyncSchemaReady:${String(apiId ?? \"unknown\")}`;\r\n\r\n  // Deletes should never block stack deletion\r\n  if (event.RequestType === \"Delete\") {\r\n    log(\"Delete request -> skipping checks\");\r\n    return { PhysicalResourceId: physicalId, Data: { skipped: true } };\r\n  }\r\n\r\n  const apiIdStr = requiredString(apiId, \"apiId\");\r\n  const regionStr = requiredString(region, \"region\");\r\n\r\n  const expected = String(expectedField ?? \"\").trim();\r\n\r\n  log(\"starting\", {\r\n    requestType: event.RequestType,\r\n    apiId: apiIdStr,\r\n    expectedField: expected || \"(none)\",\r\n    region: regionStr,\r\n    maxSchemaAttempts,\r\n    schemaDelayMs,\r\n    maxIntrospectionAttempts,\r\n    introspectionDelayMs,\r\n  });\r\n\r\n  const client = new AppSyncClient({ region: regionStr });\r\n\r\n  // 1) wait for schema creation status SUCCESS\r\n  const schemaStatus = await waitForSchemaSuccess(\r\n    client,\r\n    apiIdStr,\r\n    maxSchemaAttempts,\r\n    schemaDelayMs\r\n  );\r\n\r\n  // 2) Optional: wait for introspection to include the field (only if provided)\r\n  if (expected) {\r\n    const introspection = await waitForFieldInIntrospection(\r\n      client,\r\n      apiIdStr,\r\n      expected,\r\n      maxIntrospectionAttempts,\r\n      introspectionDelayMs\r\n    );\r\n\r\n    if (!introspection.ok) {\r\n      const message =\r\n        `Schema SUCCESS but expectedField \"${expected}\" not found via introspection after retries. ` +\r\n        `details=${schemaStatus.details || \"no details\"} (sdlLen=${introspection.sdlLen}, fieldInMutation=${introspection.fieldInMutation})`;\r\n\r\n      err(message);\r\n      throw new Error(message);\r\n    }\r\n\r\n    log(\"READY\", {\r\n      status: schemaStatus.status,\r\n      details: schemaStatus.details,\r\n      expectedField: expected,\r\n      fieldInMutation: introspection.fieldInMutation,\r\n      sdlLen: introspection.sdlLen,\r\n    });\r\n\r\n    return {\r\n      PhysicalResourceId: physicalId,\r\n      Data: {\r\n        ok: true,\r\n        apiId: apiIdStr,\r\n        expectedField: expected,\r\n        schemaStatus: schemaStatus.status,\r\n        schemaDetails: schemaStatus.details,\r\n        fieldInMutation: introspection.fieldInMutation,\r\n        sdlLen: introspection.sdlLen,\r\n      },\r\n    };\r\n  }\r\n\r\n  // No expected field check requested\r\n  log(\"READY (no expectedField check)\", {\r\n    status: schemaStatus.status,\r\n    details: schemaStatus.details,\r\n  });\r\n\r\n  return {\r\n    PhysicalResourceId: physicalId,\r\n    Data: {\r\n      ok: true,\r\n      apiId: apiIdStr,\r\n      schemaStatus: schemaStatus.status,\r\n      schemaDetails: schemaStatus.details,\r\n      expectedField: \"\",\r\n    },\r\n  };\r\n}\r\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GACA,IAAAI,EAIO,mCAaDC,EAASC,GAAe,IAAI,QAASC,GAAM,WAAWA,EAAGD,CAAE,CAAC,EAElE,SAASE,GAAS,CAChB,OAAO,IAAI,KAAK,EAAE,YAAY,CAChC,CAEA,SAASC,KAAOC,EAAa,CAC3B,QAAQ,IAAI,kBAAkBF,EAAO,CAAC,GAAI,GAAGE,CAAI,CACnD,CAEA,SAASC,KAAQD,EAAa,CAC5B,QAAQ,KAAK,kBAAkBF,EAAO,CAAC,GAAI,GAAGE,CAAI,CACpD,CAEA,SAASE,KAAOF,EAAa,CAC3B,QAAQ,MAAM,kBAAkBF,EAAO,CAAC,GAAI,GAAGE,CAAI,CACrD,CAEA,SAASG,EAAeC,EAAQC,EAAsB,CACpD,GAAI,OAAOD,GAAM,UAAYA,EAAE,KAAK,EAAE,OAAS,EAAG,OAAOA,EAAE,KAAK,EAChE,MAAM,IAAI,MAAM,qBAAqBC,CAAI,UAAU,KAAK,UAAUD,CAAC,CAAC,GAAG,CACzE,CAEA,SAASE,EAAYF,EAAQG,EAA0B,CACrD,IAAM,EAAI,OAAOH,CAAC,EAClB,OAAO,OAAO,SAAS,CAAC,GAAK,EAAI,EAAI,EAAIG,CAC3C,CAEA,SAASC,EAAkBC,EAA4B,CAErD,IAAMC,EAAID,EAAI,MAAM,iCAAiC,EACrD,OAAOC,EAAIA,EAAE,CAAC,EAAI,IACpB,CAEA,SAASC,EAAoBF,EAAaG,EAA4B,CAGpE,OADW,IAAI,OAAO,MAAMC,EAAaD,CAAS,CAAC,KAAK,EAC9C,KAAKH,CAAG,CACpB,CAEA,SAASK,EAAsBL,EAAaG,EAA4B,CACtE,IAAMG,EAAQP,EAAkBC,CAAG,EACnC,OAAKM,EACM,IAAI,OAAO,MAAMF,EAAaD,CAAS,CAAC,KAAK,EAC9C,KAAKG,CAAK,EAFD,EAGrB,CAEA,SAASF,EAAaG,EAAW,CAC/B,OAAOA,EAAE,QAAQ,sBAAuB,MAAM,CAChD,CAEA,eAAeC,EAAgBC,EAAuBC,EAAe,CACnE,IAAMC,EAAO,MAAMF,EAAO,KAAK,IAAI,iCAA+B,CAAE,MAAAC,CAAM,CAAC,CAAC,EAE5E,MAAO,CACL,OAAQC,EAAK,QAAU,UACvB,QAASA,EAAK,SAAW,EAC3B,CACF,CAEA,eAAeC,EAAoBH,EAAuBC,EAAe,CAWvE,IAAMG,GAVO,MAAMJ,EAAO,KACxB,IAAI,gCAA8B,CAChC,MAAAC,EACA,OAAQ,KACV,CAAC,CACH,GAKiB,OACjB,OAAKG,GAGH,OAAOA,GAAQ,SACX,OAAO,KAAKA,EAAK,QAAQ,EACzB,OAAO,KAAKA,CAAiB,GAExB,SAAS,MAAM,EAPT,EAQnB,CAEA,eAAeC,EACbL,EACAC,EACAK,EACAC,EACA,CACA,QAASC,EAAI,EAAGA,GAAKF,EAAaE,IAAK,CACrC,GAAM,CAAE,OAAAC,EAAQ,QAAAC,CAAQ,EAAI,MAAMX,EAAgBC,EAAQC,CAAK,EAI/D,GAFApB,EAAI,yBAAyB2B,CAAC,IAAIF,CAAW,KAAKG,CAAM,KAAKC,CAAO,GAAG,EAEnED,IAAW,UAAW,MAAO,CAAE,OAAAA,EAAQ,QAAAC,CAAQ,EACnD,GAAID,IAAW,SACb,MAAM,IAAI,MAAM,yBAAyBC,GAAW,YAAY,EAAE,EAIpE,MAAMjC,EAAM8B,CAAO,CACrB,CAEA,MAAM,IAAI,MAAM,+CAA+C,CACjE,CAEA,eAAeI,EACbX,EACAC,EACAW,EACAN,EACAC,EACA,CACA,IAAIM,EAAa,EACbC,EAAuB,GAE3B,QAASN,EAAI,EAAGA,GAAKF,EAAaE,IAAK,CACrC,IAAIjB,EAAM,GACV,GAAI,CACFA,EAAM,MAAMY,EAAoBH,EAAQC,CAAK,CAC/C,OAASc,EAAQ,CACfhC,EAAK,yBAAyByB,CAAC,IAAIF,CAAW,UAAWS,GAAG,SAAWA,CAAC,EACxE,MAAMtC,EAAM8B,CAAO,EACnB,QACF,CAEAM,EAAatB,EAAI,OAEjB,IAAMyB,EAAWvB,EAAoBF,EAAKqB,CAAa,EACjDK,EAAarB,EAAsBL,EAAKqB,CAAa,EAQ3D,GAPAE,EAAuBG,EAEvBpC,EACE,yBAAyB2B,CAAC,IAAIF,CAAW,YAAYf,EAAI,MAAM,kBAAkByB,CAAQ,oBAAoBC,CAAU,EACzH,EAGIT,IAAM,EAAG,CACX3B,EAAI,iCAAkC,KAAK,UAAUU,EAAI,MAAM,EAAG,GAAI,CAAC,CAAC,EACxE,IAAM2B,EAAa3B,EAAI,MAAM,gCAAgC,EACzD2B,EACFrC,EAAI,qBAAsB,KAAK,UAAUqC,EAAW,CAAC,CAAC,CAAC,EAEvDrC,EAAI,oCAAoC,CAE5C,CAIA,GAAImC,EAAU,CAEZ,IAAMG,EAAM5B,EAAI,OAAO,IAAI,OAAO,MAAMI,EAAaiB,CAAa,CAAC,KAAK,CAAC,EACzE,GAAIO,GAAO,EAAG,CACZ,IAAMC,EAAQ,KAAK,IAAI,EAAGD,EAAM,EAAE,EAC5BE,EAAM,KAAK,IAAI9B,EAAI,OAAQ4B,EAAM,GAAG,EAC1CtC,EAAI,yBAA0B,KAAK,UAAUU,EAAI,MAAM6B,EAAOC,CAAG,CAAC,CAAC,CACrE,CACA,MAAO,CACL,GAAI,GACJ,cAAe,GACf,gBAAiBJ,EACjB,OAAQ1B,EAAI,MACd,CACF,CAGA,IAAM+B,EAAS,KAAK,MAAM,KAAK,OAAO,EAAI,KAAK,IAAI,IAAKf,CAAO,CAAC,EAChE,MAAM9B,EAAM8B,EAAUe,CAAM,CAC9B,CAEA,MAAO,CACL,GAAI,GACJ,cAAe,GACf,gBAAiBR,EACjB,OAAQD,CACV,CACF,CAEA,eAAsBvC,EAAQiD,EAAuD,CACnF,IAAMC,EAAQD,GAAO,oBAAsB,CAAC,EAGtCtB,EACH,QAAQ,IAAI,gBACZ,QAAQ,IAAI,QACbuB,EAAM,OACNA,EAAM,MAEFZ,EACH,QAAQ,IAAI,gBACbY,EAAM,eACNA,EAAM,cAEFC,EACH,QAAQ,IAAI,YACZ,QAAQ,IAAI,QACbD,EAAM,QACNA,EAAM,OAEFE,EAAoBtC,EACxB,QAAQ,IAAI,4BAA8BoC,EAAM,wBAChD,EACF,EACMG,EAAgBvC,EACpB,QAAQ,IAAI,wBAA0BoC,EAAM,oBAC5C,GACF,EAEMI,EAA2BxC,EAC/B,QAAQ,IAAI,4BAA8BoC,EAAM,yBAChD,EACF,EACMK,EAAuBzC,EAC3B,QAAQ,IAAI,wBAA0BoC,EAAM,qBAC5C,IACF,EAEMM,EACJP,EAAM,oBACN,sBAAsB,OAAOtB,GAAS,SAAS,CAAC,GAGlD,GAAIsB,EAAM,cAAgB,SACxB,OAAA1C,EAAI,mCAAmC,EAChC,CAAE,mBAAoBiD,EAAY,KAAM,CAAE,QAAS,EAAK,CAAE,EAGnE,IAAMC,EAAW9C,EAAegB,EAAO,OAAO,EACxC+B,EAAY/C,EAAewC,EAAQ,QAAQ,EAE3CQ,EAAW,OAAOrB,GAAiB,EAAE,EAAE,KAAK,EAElD/B,EAAI,WAAY,CACd,YAAa0C,EAAM,YACnB,MAAOQ,EACP,cAAeE,GAAY,SAC3B,OAAQD,EACR,kBAAAN,EACA,cAAAC,EACA,yBAAAC,EACA,qBAAAC,CACF,CAAC,EAED,IAAM7B,EAAS,IAAI,gBAAc,CAAE,OAAQgC,CAAU,CAAC,EAGhDE,EAAe,MAAM7B,EACzBL,EACA+B,EACAL,EACAC,CACF,EAGA,GAAIM,EAAU,CACZ,IAAME,EAAgB,MAAMxB,EAC1BX,EACA+B,EACAE,EACAL,EACAC,CACF,EAEA,GAAI,CAACM,EAAc,GAAI,CACrB,IAAMC,EACJ,qCAAqCH,CAAQ,wDAClCC,EAAa,SAAW,YAAY,YAAYC,EAAc,MAAM,qBAAqBA,EAAc,eAAe,IAEnI,MAAAnD,EAAIoD,CAAO,EACL,IAAI,MAAMA,CAAO,CACzB,CAEA,OAAAvD,EAAI,QAAS,CACX,OAAQqD,EAAa,OACrB,QAASA,EAAa,QACtB,cAAeD,EACf,gBAAiBE,EAAc,gBAC/B,OAAQA,EAAc,MACxB,CAAC,EAEM,CACL,mBAAoBL,EACpB,KAAM,CACJ,GAAI,GACJ,MAAOC,EACP,cAAeE,EACf,aAAcC,EAAa,OAC3B,cAAeA,EAAa,QAC5B,gBAAiBC,EAAc,gBAC/B,OAAQA,EAAc,MACxB,CACF,CACF,CAGA,OAAAtD,EAAI,iCAAkC,CACpC,OAAQqD,EAAa,OACrB,QAASA,EAAa,OACxB,CAAC,EAEM,CACL,mBAAoBJ,EACpB,KAAM,CACJ,GAAI,GACJ,MAAOC,EACP,aAAcG,EAAa,OAC3B,cAAeA,EAAa,QAC5B,cAAe,EACjB,CACF,CACF",
  "names": ["appsync_schema_ready_exports", "__export", "handler", "__toCommonJS", "import_client_appsync", "sleep", "ms", "r", "nowIso", "log", "args", "warn", "err", "requiredString", "v", "name", "parseNumber", "fallback", "findMutationBlock", "sdl", "m", "fieldExistsAnywhere", "fieldName", "escapeRegExp", "fieldExistsInMutation", "block", "s", "getSchemaStatus", "client", "apiId", "resp", "getIntrospectionSdl", "raw", "waitForSchemaSuccess", "maxAttempts", "delayMs", "i", "status", "details", "waitForFieldInIntrospection", "expectedField", "lastSdlLen", "lastMutationHasField", "e", "anywhere", "inMutation", "queryMatch", "idx", "start", "end", "jitter", "event", "props", "region", "maxSchemaAttempts", "schemaDelayMs", "maxIntrospectionAttempts", "introspectionDelayMs", "physicalId", "apiIdStr", "regionStr", "expected", "schemaStatus", "introspection", "message"]
}
