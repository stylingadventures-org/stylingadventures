{
  "version": 3,
  "sources": ["../../lambda/closet/admin.ts"],
  "sourcesContent": ["// lambda/closet/admin.ts\r\n//\r\n// AppSync \"admin\" Lambda for closet moderation:\r\n//   - Query.adminListPending   (returns PENDING / APPROVED / PUBLISHED items)\r\n//   - Mutation.adminApproveItem\r\n//   - Mutation.adminRejectItem\r\n//   - Mutation.adminSetClosetAudience\r\n\r\nimport {\r\n  DynamoDBClient,\r\n  UpdateItemCommand,\r\n  ScanCommand,\r\n  QueryCommand,\r\n} from \"@aws-sdk/client-dynamodb\";\r\nimport { unmarshall } from \"@aws-sdk/util-dynamodb\";\r\n\r\nconst ddb = new DynamoDBClient({});\r\nconst TABLE_NAME = process.env.APP_TABLE!;\r\n\r\ntype ClosetStatus = \"DRAFT\" | \"PENDING\" | \"APPROVED\" | \"REJECTED\" | \"PUBLISHED\";\r\ntype ClosetAudience = \"PUBLIC\" | \"BESTIE\" | \"EXCLUSIVE\";\r\n\r\ntype ClosetItem = {\r\n  id: string;\r\n  userId: string;\r\n  ownerSub: string;\r\n  status: ClosetStatus;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  mediaKey?: string | null;\r\n  title?: string | null;\r\n  reason?: string | null;\r\n  audience?: ClosetAudience | null;\r\n};\r\n\r\ntype AppSyncEvent = {\r\n  info: { fieldName: string; parentTypeName: string };\r\n  arguments: any;\r\n};\r\n\r\n// ---------- helpers ----------\r\n\r\nfunction mapClosetItem(raw: any): ClosetItem {\r\n  const it = unmarshall(raw) as any;\r\n  return {\r\n    id: String(it.id),\r\n    userId: String(it.userId ?? it.ownerSub ?? \"\"),\r\n    ownerSub: String(it.ownerSub ?? it.userId ?? \"\"),\r\n    status: (it.status ?? \"PENDING\") as ClosetStatus,\r\n    createdAt: String(it.createdAt),\r\n    updatedAt: String(it.updatedAt ?? it.createdAt),\r\n    mediaKey: it.mediaKey ?? null,\r\n    title: it.title ?? null,\r\n    reason: it.reason ?? null,\r\n    audience: (it.audience ?? \"PUBLIC\") as ClosetAudience,\r\n  };\r\n}\r\n\r\n/**\r\n * Locate an item by id.\r\n *\r\n * We keep this simple and just Scan by \"id\" so we don't have to guess\r\n * your exact pk/sk pattern.\r\n */\r\nasync function findRawItemById(id: string) {\r\n  const resp = await ddb.send(\r\n    new ScanCommand({\r\n      TableName: TABLE_NAME,\r\n      FilterExpression: \"#id = :id\",\r\n      ExpressionAttributeNames: {\r\n        \"#id\": \"id\",\r\n      },\r\n      ExpressionAttributeValues: {\r\n        \":id\": { S: id },\r\n      },\r\n      Limit: 1,\r\n    }),\r\n  );\r\n\r\n  if (!resp.Items || resp.Items.length === 0) return null;\r\n  return resp.Items[0];\r\n}\r\n\r\n/** Extract pk/sk from a table record (DataStack uses pk/sk). */\r\nfunction pkOf(raw: any) {\r\n  if (raw.pk?.S && raw.sk?.S) {\r\n    return { pk: raw.pk.S as string, sk: raw.sk.S as string };\r\n  }\r\n  throw new Error(\"Could not infer pk/sk for closet item\");\r\n}\r\n\r\n// ---------- resolvers ----------\r\n\r\n/**\r\n * Return all closet items that the admin might care about:\r\n * PENDING, APPROVED, or PUBLISHED items that live on the gsi1 index\r\n * under gsi1pk = \"CLOSET\" (same pattern as the fan feed).\r\n */\r\nasync function adminListPending(): Promise<ClosetItem[]> {\r\n  const resp = await ddb.send(\r\n    new QueryCommand({\r\n      TableName: TABLE_NAME,\r\n      IndexName: \"gsi1\",\r\n      KeyConditionExpression: \"#pk = :pk\",\r\n      ExpressionAttributeNames: {\r\n        \"#pk\": \"gsi1pk\",\r\n        \"#status\": \"status\",\r\n      },\r\n      ExpressionAttributeValues: {\r\n        \":pk\": { S: \"CLOSET\" },\r\n        \":pending\": { S: \"PENDING\" },\r\n        \":approved\": { S: \"APPROVED\" },\r\n        \":published\": { S: \"PUBLISHED\" },\r\n      },\r\n      // filter down to the statuses we care about for moderation\r\n      FilterExpression:\r\n        \"#status = :pending OR #status = :approved OR #status = :published\",\r\n    }),\r\n  );\r\n\r\n  return (resp.Items || []).map(mapClosetItem);\r\n}\r\n\r\nasync function adminApproveItem(args: {\r\n  id: string;\r\n}): Promise<ClosetItem> {\r\n  const base = await findRawItemById(args.id);\r\n  if (!base) {\r\n    throw new Error(`Closet item not found for id=${args.id}`);\r\n  }\r\n\r\n  const { pk, sk } = pkOf(base);\r\n  const now = new Date().toISOString();\r\n\r\n  const resp = await ddb.send(\r\n    new UpdateItemCommand({\r\n      TableName: TABLE_NAME,\r\n      Key: { pk: { S: pk }, sk: { S: sk } },\r\n      UpdateExpression:\r\n        \"SET #status = :approved, #updatedAt = :now REMOVE #reason\",\r\n      ExpressionAttributeNames: {\r\n        \"#status\": \"status\",\r\n        \"#updatedAt\": \"updatedAt\",\r\n        \"#reason\": \"reason\",\r\n      },\r\n      ExpressionAttributeValues: {\r\n        \":approved\": { S: \"APPROVED\" },\r\n        \":now\": { S: now },\r\n      },\r\n      ReturnValues: \"ALL_NEW\",\r\n    }),\r\n  );\r\n\r\n  if (!resp.Attributes) {\r\n    throw new Error(\"adminApproveItem: update returned no attributes\");\r\n  }\r\n  return mapClosetItem(resp.Attributes);\r\n}\r\n\r\nasync function adminRejectItem(args: {\r\n  id: string;\r\n  reason?: string | null;\r\n}): Promise<ClosetItem> {\r\n  const base = await findRawItemById(args.id);\r\n  if (!base) {\r\n    throw new Error(`Closet item not found for id=${args.id}`);\r\n  }\r\n\r\n  const { pk, sk } = pkOf(base);\r\n  const now = new Date().toISOString();\r\n  const hasReason = !!args.reason && args.reason.trim().length > 0;\r\n\r\n  const resp = await ddb.send(\r\n    new UpdateItemCommand({\r\n      TableName: TABLE_NAME,\r\n      Key: { pk: { S: pk }, sk: { S: sk } },\r\n      UpdateExpression: hasReason\r\n        ? \"SET #status = :rejected, #updatedAt = :now, #reason = :reason\"\r\n        : \"SET #status = :rejected, #updatedAt = :now REMOVE #reason\",\r\n      ExpressionAttributeNames: {\r\n        \"#status\": \"status\",\r\n        \"#updatedAt\": \"updatedAt\",\r\n        \"#reason\": \"reason\",\r\n      },\r\n      ExpressionAttributeValues: {\r\n        \":rejected\": { S: \"REJECTED\" },\r\n        \":now\": { S: now },\r\n        ...(hasReason ? { \":reason\": { S: args.reason! } } : {}),\r\n      },\r\n      ReturnValues: \"ALL_NEW\",\r\n    }),\r\n  );\r\n\r\n  if (!resp.Attributes) {\r\n    throw new Error(\"adminRejectItem: update returned no attributes\");\r\n  }\r\n  return mapClosetItem(resp.Attributes);\r\n}\r\n\r\n/**\r\n * Set visibility for a closet item (PUBLIC / BESTIE / EXCLUSIVE).\r\n */\r\nasync function adminSetClosetAudience(args: {\r\n  id: string;\r\n  audience: ClosetAudience;\r\n}): Promise<ClosetItem> {\r\n  const base = await findRawItemById(args.id);\r\n  if (!base) {\r\n    throw new Error(`Closet item not found for id=${args.id}`);\r\n  }\r\n\r\n  const { pk, sk } = pkOf(base);\r\n  const now = new Date().toISOString();\r\n\r\n  const resp = await ddb.send(\r\n    new UpdateItemCommand({\r\n      TableName: TABLE_NAME,\r\n      Key: { pk: { S: pk }, sk: { S: sk } },\r\n      UpdateExpression: \"SET #audience = :aud, #updatedAt = :now\",\r\n      ExpressionAttributeNames: {\r\n        \"#audience\": \"audience\",\r\n        \"#updatedAt\": \"updatedAt\",\r\n      },\r\n      ExpressionAttributeValues: {\r\n        \":aud\": { S: args.audience },\r\n        \":now\": { S: now },\r\n      },\r\n      ReturnValues: \"ALL_NEW\",\r\n    }),\r\n  );\r\n\r\n  if (!resp.Attributes) {\r\n    throw new Error(\"adminSetClosetAudience: update returned no attributes\");\r\n  }\r\n  return mapClosetItem(resp.Attributes);\r\n}\r\n\r\n// ---------- handler ----------\r\n\r\nexport const handler = async (event: AppSyncEvent) => {\r\n  const { fieldName, parentTypeName } = event.info;\r\n\r\n  if (parentTypeName === \"Query\") {\r\n    if (fieldName === \"adminListPending\") {\r\n      return adminListPending();\r\n    }\r\n  }\r\n\r\n  if (parentTypeName === \"Mutation\") {\r\n    if (fieldName === \"adminApproveItem\") {\r\n      return adminApproveItem(event.arguments);\r\n    }\r\n    if (fieldName === \"adminRejectItem\") {\r\n      return adminRejectItem(event.arguments);\r\n    }\r\n    if (fieldName === \"adminSetClosetAudience\") {\r\n      return adminSetClosetAudience(event.arguments);\r\n    }\r\n  }\r\n\r\n  throw new Error(\r\n    `Unknown field ${parentTypeName}.${fieldName} in ClosetAdminFn`,\r\n  );\r\n};\r\n"],
  "mappings": "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",
  "names": ["admin_exports", "__export", "handler", "__toCommonJS", "import_client_dynamodb", "import_util_dynamodb", "ddb", "TABLE_NAME", "mapClosetItem", "raw", "it", "findRawItemById", "id", "resp", "pkOf", "adminListPending", "adminApproveItem", "args", "base", "pk", "sk", "now", "adminRejectItem", "hasReason", "adminSetClosetAudience", "event", "fieldName", "parentTypeName"]
}
