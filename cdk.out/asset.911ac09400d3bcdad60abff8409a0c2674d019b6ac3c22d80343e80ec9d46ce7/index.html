<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Styling Adventures</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="/styles.css" />
  <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
</head>
<body class="sa-body">
  <h1>StylingAdventures</h1>

  <div class="actions">
    <a id="signin" href="#" class="sa-link">Sign in</a>
    <button id="signout" class="sa-btn sa-btn-outline ml-2">Sign out</button>
    <button id="signout-global" class="sa-btn sa-btn-outline ml-2">Sign out everywhere</button>
  </div>

  <h2>Status</h2>
  <div id="status" class="sa-card">Loading…</div>
  <button id="refresh-now" class="sa-btn mt-2" aria-label="Refresh tokens now">Refresh tokens now</button>

  <h3>Debug</h3>
  <pre id="dbg" class="sa-pre sa-muted"></pre>

  <!-- AppSync hello -->
  <h2>AppSync hello</h2>
  <div class="sa-card">
    <button id="btn-hello" class="sa-btn">Call { hello }</button>
    <span id="hello-out" class="ml-2 sa-muted" aria-live="polite"></span>
  </div>

  <!-- Uploads -->
  <h2>Uploads</h2>
  <div class="sa-card">
    <div class="form-row">
      <!-- Optional key prefix; leave blank to use just the filenames -->
      <label for="upload-key" class="sa-label">Key prefix (optional)</label>
      <input id="upload-key" name="key" placeholder="e.g. photos/" class="sa-input" />
    </div>

    <div class="form-row">
      <label for="upload-file" class="sa-label">Files</label>
      <input id="upload-file" name="file" type="file" multiple class="sa-input" />
    </div>

    <!-- Drag & Drop area -->
    <div id="dropzone" class="sa-card sa-muted" style="padding: 20px; border: 2px dashed #bbb; border-radius: 10px;">
      Drag & drop files here, or use the file picker above.
    </div>

    <button id="btn-upload" class="sa-btn mt-2" aria-label="Upload file(s) and list existing uploads">
      Upload selected files
    </button>

    <p id="uploads-msg" class="sa-muted mt-2" aria-live="polite"></p>

    <!-- Rendered list with per-item progress + delete -->
    <ul id="upload-list" class="sa-muted mt-2"></ul>
  </div>

  <script type="module">
    // ================= common bits you already had =================
    const cfg = await fetch(`/config.json?ts=${Date.now()}`, { cache: 'no-store' }).then(r => r.json());
    const domain = `https://${cfg.domain}.auth.${cfg.region}.amazoncognito.com`;
    const authorizeUrl = `${domain}/oauth2/authorize`;
    const logoutUrl = `${domain}/logout?client_id=${encodeURIComponent(cfg.clientId)}&logout_uri=${encodeURIComponent(cfg.logoutUri)}`;
    const api = cfg.uploadsUrl.replace(/\/+$/, '');

    const $ = s => document.querySelector(s);
    const enc = new TextEncoder();

    function base64Url(uint8) { return btoa(String.fromCharCode(...uint8)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, ''); }
    function randBytes(n){ const a=new Uint8Array(n); crypto.getRandomValues(a); return a; }
    function randomString(n=32){ return base64Url(randBytes(n)); }
    async function sha256(str){ const h=await crypto.subtle.digest('SHA-256', enc.encode(str)); return new Uint8Array(h); }

    async function startLogin(){
      const verifier = randomString(64);
      sessionStorage.setItem('pkce_verifier', verifier);
      const challenge = base64Url(await sha256(verifier));
      const state = randomString(24);
      sessionStorage.setItem('oauth_state', state);
      const url = new URL(authorizeUrl);
      url.searchParams.set('response_type','code');
      url.searchParams.set('client_id', cfg.clientId);
      url.searchParams.set('redirect_uri', cfg.redirectUri);
      url.searchParams.set('scope','openid email profile');
      url.searchParams.set('code_challenge', challenge);
      url.searchParams.set('code_challenge_method','S256');
      url.searchParams.set('state', state);
      location.assign(url.toString());
    }

    function signOutLocal(){ sessionStorage.clear(); render(); }

    async function signOutEverywhere(){
      try{
        const refresh = sessionStorage.getItem('refresh_token') || (JSON.parse(sessionStorage.getItem('tokens')||'{}').refresh_token);
        if (refresh){
          const body = new URLSearchParams({ token: refresh, token_type_hint:'refresh_token', client_id: cfg.clientId });
          await fetch(`${domain}/oauth2/revoke`, { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body }).catch(()=>{});
        }
      } finally {
        sessionStorage.clear();
        location.replace(logoutUrl);
      }
    }

    function parseJwt(t){ if(!t) return null; try{ return JSON.parse(atob(t.split('.')[1].replace(/-/g,'+').replace(/_/g,'/')));}catch{return null;} }
    function secondsLeft(id){ const p=parseJwt(id); return p?.exp ? Math.max(0, p.exp - Math.floor(Date.now()/1000)) : 0; }

    async function ensureFreshIdToken(minSeconds=60){
      let id = sessionStorage.getItem('id_token');
      if (!id) return null;
      if (secondsLeft(id) > minSeconds) return id;
      const { refreshTokens, scheduleRotation } = await import('/auth/refresh.js');
      const out = await refreshTokens({ domain, clientId: cfg.clientId });
      scheduleRotation(out, { domain, clientId: cfg.clientId });
      render();
      return out.id_token || sessionStorage.getItem('id_token');
    }

    function render(){
      const id = sessionStorage.getItem('id_token');
      $('#signin').style.display = id ? 'none' : 'inline';
      $('#signout').style.display = id ? 'inline-block' : 'none';
      $('#signout-global').style.display = id ? 'inline-block' : 'none';
      const left = secondsLeft(id);
      const mins = Math.floor(left/60);
      const secs = String(left%60).padStart(2,'0');
      $('#status').textContent = id ? `Signed in as ${parseJwt(id)?.email || 'unknown'} · ID token expires in ${mins}:${secs}` : 'Not signed in';
      $('#dbg').textContent = id ? JSON.stringify(parseJwt(id) || {}, null, 2) : '';
    }

    async function callHello(){
      const id = await ensureFreshIdToken();
      if (!id){ alert('Please sign in first'); return; }
      const res = await fetch(cfg.appsyncUrl,{
        method:'POST',
        headers:{ 'Content-Type':'application/json', 'Authorization': id },
        body: JSON.stringify({ query: `query Hello { hello }` })
      });
      if (!res.ok) throw new Error(`AppSync ${res.status}: ${await res.text()}`);
      const json = await res.json();
      $('#hello-out').textContent = json.data?.hello ?? '(no data)';
    }

    // ================= new UX helpers =================
    function toast(text, type='info'){
      const el = $('#uploads-msg');
      el.textContent = text;
      el.className = `sa-muted mt-2 ${type==='error' ? 'sa-error' : ''}`;
    }

    function liRow(name){
      const li = document.createElement('li');
      li.style.margin = '6px 0';
      li.innerHTML = `
        <div style="display:flex; align-items:center; gap:8px;">
          <strong style="min-width:160px; word-break:break-all;">${name}</strong>
          <progress max="100" value="0" style="width:260px;"></progress>
          <span class="sa-muted status"></span>
          <button class="sa-btn sa-btn-outline sa-sm delete" style="margin-left:auto; display:none;">Delete</button>
        </div>
      `;
      return li;
    }

    // ================= listing + delete =================
    async function listUploads(){
      const id = sessionStorage.getItem('id_token');
      if (!id) return;
      const res = await fetch(`${api}/list`, { headers:{ Authorization: id }});
      if (!res.ok) return;
      const data = await res.json();
      const keys = Array.isArray(data) ? data : (data.items ?? data.keys ?? []);
      const ul = $('#upload-list');
      ul.innerHTML = '';

      keys.forEach(key => {
        const li = liRow(key);
        li.querySelector('progress').style.display = 'none';
        li.querySelector('.status').textContent = '';
        const delBtn = li.querySelector('.delete');
        delBtn.style.display = 'inline-block';
        delBtn.addEventListener('click', async () => {
          const idTok = await ensureFreshIdToken();
          if (!confirm(`Delete "${key}"?`)) return;
          const r = await fetch(`${api}/delete?key=${encodeURIComponent(key)}`, { method:'DELETE', headers:{ Authorization: idTok }});
          if (!r.ok){ alert(`Delete failed: ${r.status} ${await r.text()}`); return; }
          li.remove();
        });
        ul.appendChild(li);
      });
    }

    // ================= drag & drop =================
    const drop = $('#dropzone');
    ;['dragenter','dragover','dragleave','drop'].forEach(ev=>{
      drop.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); }, false);
    });
    drop.addEventListener('dragover', () => drop.style.borderColor = '#666');
    drop.addEventListener('dragleave', () => drop.style.borderColor = '#bbb');
    drop.addEventListener('drop', e => {
      drop.style.borderColor = '#bbb';
      const files = [...(e.dataTransfer?.files || [])];
      if (files.length){
        const input = /** @type {HTMLInputElement} */($('#upload-file'));
        // put dropped files into the input for convenience
        // (not all browsers let us set .files, so we just kick off upload directly)
        startUpload(files);
      }
    });

    // mirror filename into key prefix if empty & only one file selected
    $('#upload-file')?.addEventListener('change', e => {
      // we keep "key prefix" as-is; filenames are used automatically
    });

    // ================= multi upload with progress =================
    const MAX_MB = 50;
    const ALLOW_TYPES = ['text/plain','image/png','image/jpeg','image/gif','application/pdf','video/mp4'];
    const CONCURRENCY = 4;

    async function presign(id, key, type){
      const r = await fetch(`${api}/presign`, {
        method:'POST',
        headers:{ Authorization: id, 'Content-Type':'application/json' },
        body: JSON.stringify({ key, contentType: type || 'application/octet-stream' })
      });
      const txt = await r.text();
      let json; try{ json = JSON.parse(txt); }catch{}
      if (!r.ok || !json?.url) throw new Error(`presign ${r.status}: ${txt}`);
      return json;
    }

    function putWithProgress(url, file, headers){
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('PUT', url);
        Object.entries(headers || {}).forEach(([k,v]) => xhr.setRequestHeader(k, v));
        xhr.upload.onprogress = e => {
          if (e.lengthComputable) rowProg.value = Math.round((e.loaded/e.total)*100);
        };
        xhr.onload = () => (xhr.status>=200 && xhr.status<300) ? resolve(null) : reject(new Error(`S3 PUT ${xhr.status}: ${xhr.responseText}`));
        xhr.onerror = () => reject(new Error('Network error during upload'));
        xhr.send(file);

        // expose a handle to update progress from outside
        var rowProg = null;
        xhr._attachProgress = el => { rowProg = el; };
      });
    }

    async function startUpload(filesArg){
      const files = filesArg ?? [.../** @type {HTMLInputElement} */($('#upload-file')).files];
      const prefix = ($('#upload-key').value || '').trim(); // optional
      if (!files.length){ toast('Choose or drop files first', 'error'); return; }

      // basic validation first (fail fast)
      for (const f of files){
        if (f.size > MAX_MB*1024*1024){ toast(`"${f.name}" too large. Max ${MAX_MB} MB.`, 'error'); return; }
        if (ALLOW_TYPES.length && !ALLOW_TYPES.includes(f.type) && !ALLOW_TYPES.some(t => t.endsWith('/*') && f.type.startsWith(t.slice(0,-1)))){
          toast(`"${f.name}": type not allowed (${f.type||'unknown'}).`, 'error'); return;
        }
      }

      const id = await ensureFreshIdToken();
      if (!id){ toast('Please sign in first', 'error'); return; }

      const ul = $('#upload-list');
      const rows = files.map(f => {
        const key = (prefix ? prefix.replace(/^\/*/,'').replace(/\/+$/,'')+'/' : '') + f.name;
        const li = liRow(f.name);
        ul.prepend(li); // show newest on top
        const prog = li.querySelector('progress');
        const status = li.querySelector('.status');
        status.textContent = 'preparing…';
        return { f, key, li, prog, status };
      });

      // simple concurrency pool
      let active = 0, idx = 0, errors = 0;
      toast(`Uploading ${files.length} file(s)…`);

      await new Promise((done) => {
        const next = async () => {
          if (idx >= rows.length){ if (active===0) done(); return; }
          const row = rows[idx++]; active++;
          try {
            row.status.textContent = 'presigning…';
            const { url, headers } = await presign(id, row.key, row.f.type || 'application/octet-stream');
            row.status.textContent = 'uploading…';
            await new Promise((resolve, reject) => {
              const xhr = new XMLHttpRequest();
              xhr.open('PUT', url);
              Object.entries(headers || { 'Content-Type': row.f.type || 'application/octet-stream' }).forEach(([k,v]) => xhr.setRequestHeader(k,v));
              xhr.upload.onprogress = e => { if (e.lengthComputable) row.prog.value = Math.round((e.loaded/e.total)*100); };
              xhr.onload = () => (xhr.status>=200 && xhr.status<300) ? resolve(null) : reject(new Error(`S3 PUT ${xhr.status}: ${xhr.responseText}`));
              xhr.onerror = () => reject(new Error('Network error'));
              xhr.send(row.f);
            });
            row.status.textContent = 'done';
            row.prog.style.display = 'none';
            // show delete after upload
            row.li.querySelector('.delete').style.display = 'inline-block';
          } catch (e){
            errors++; console.error(e);
            row.status.textContent = `error: ${e.message || e}`;
            row.prog.style.display = 'none';
            row.li.style.color = '#b00020';
          } finally {
            active--; next();
          }
        };
        for (let i=0; i<CONCURRENCY && i<rows.length; i++) next();
      });

      if (errors) toast(`Finished with ${errors} error(s)`, 'error'); else toast('All uploads complete ✔');
      await listUploads();
    }

    // ================= wire up =================
    $('#signin').addEventListener('click', e => { e.preventDefault(); startLogin(); });
    $('#signout').addEventListener('click', e => { e.preventDefault(); signOutLocal(); });
    $('#signout-global').addEventListener('click', e => { e.preventDefault(); signOutEverywhere(); });
    $('#btn-hello')?.addEventListener('click', e => { e.preventDefault(); callHello().catch(err => $('#hello-out').textContent = `Error: ${err.message}`); });
    $('#btn-upload')?.addEventListener('click', e => { e.preventDefault(); startUpload().catch(err => alert(err.message)); });

    // Backfill + rotation + manual refresh (unchanged)
    (function backfill(){
      if (!sessionStorage.getItem('tokens')){
        const id = sessionStorage.getItem('id_token');
        const at = sessionStorage.getItem('access_token');
        const rt = sessionStorage.getItem('refresh_token');
        if (id && at && rt) sessionStorage.setItem('tokens', JSON.stringify({ id_token:id, access_token:at, refresh_token:rt, expires_in:3600 }));
      }
    })();
    (async function ensureRotation(){
      const raw = sessionStorage.getItem('tokens'); if (!raw) return;
      const tokens = JSON.parse(raw);
      const { scheduleRotation } = await import('/auth/refresh.js');
      scheduleRotation(tokens, { domain, clientId: cfg.clientId });
    })();
    $('#refresh-now')?.addEventListener('click', async e => {
      e.preventDefault();
      const { refreshTokens, scheduleRotation } = await import('/auth/refresh.js');
      try{
        const out = await refreshTokens({ domain, clientId: cfg.clientId });
        scheduleRotation(out, { domain, clientId: cfg.clientId });
        render();
      }catch(err){ alert(`Refresh failed: ${err.message||err}`); }
    });

    render();
    setInterval(render, 1000);
    if (sessionStorage.getItem('id_token')) listUploads();
  </script>
</body>
</html>

