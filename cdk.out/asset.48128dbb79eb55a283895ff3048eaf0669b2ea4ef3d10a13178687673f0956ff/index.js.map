{
  "version": 3,
  "sources": ["../../lambda/episodes/gate.ts", "../../lambda/_shared/env.ts"],
  "sourcesContent": ["// lambda/episodes/gate.ts\r\nimport { DynamoDBClient } from \"@aws-sdk/client-dynamodb\";\r\nimport {\r\n  DynamoDBDocumentClient,\r\n  GetCommand,\r\n  PutCommand,\r\n  UpdateCommand,\r\n  QueryCommand,\r\n} from \"@aws-sdk/lib-dynamodb\";\r\nimport { AppSyncIdentityCognito } from \"aws-lambda\";\r\nimport { TABLE_NAME } from \"../_shared/env\";\r\n\r\nconst ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}), {\r\n  marshallOptions: { removeUndefinedValues: true },\r\n});\r\n\r\ntype SAIdentity =\r\n  | (AppSyncIdentityCognito & { groups?: string[] | null })\r\n  | null\r\n  | undefined;\r\n\r\ntype AppSyncEvent = {\r\n  info: { fieldName: string };\r\n  arguments: any;\r\n  identity?: SAIdentity;\r\n};\r\n\r\n// Helpers ---------------------------------------------------\r\n\r\nfunction episodePk(id: string) {\r\n  return `EPISODE#${id}`;\r\n}\r\nconst EP_SK = \"META\";\r\n\r\nfunction profilePk(sub: string) {\r\n  return `USER#${sub}`;\r\n}\r\nconst PROFILE_SK = \"PROFILE\";\r\n\r\nfunction unlockSk(epId: string) {\r\n  return `EP_UNLOCK#${epId}`;\r\n}\r\n\r\nfunction mapEpisode(it: any) {\r\n  if (!it) return null;\r\n  return {\r\n    id: (it.id || it.episodeId || (it.pk || \"\").replace(\"EPISODE#\", \"\")) as string,\r\n    title: it.title || \"\",\r\n    season: it.season ?? null,\r\n    episodeNumber: it.episodeNumber ?? null,\r\n    showId: it.showId ?? null,\r\n    shortDescription: it.shortDescription ?? \"\",\r\n    fullDescription: it.fullDescription ?? \"\",\r\n    status: (it.status || \"DRAFT\") as string,\r\n    publicAt: it.publicAt || new Date().toISOString(),\r\n    durationSeconds: it.durationSeconds ?? null,\r\n    unlockCoinCost: it.unlockCoinCost ?? null,\r\n    chatEnabled: it.chatEnabled ?? true,\r\n    thumbnails: Array.isArray(it.thumbnails) ? it.thumbnails : [],\r\n    outfitsLinkedCount: it.outfitsLinkedCount ?? 0,\r\n  };\r\n}\r\n\r\nasync function loadEpisode(episodeId: string) {\r\n  const got = await ddb.send(\r\n    new GetCommand({\r\n      TableName: TABLE_NAME,\r\n      Key: { pk: episodePk(episodeId), sk: EP_SK },\r\n    }),\r\n  );\r\n  if (!got.Item) throw new Error(\"Episode not found\");\r\n  return got.Item;\r\n}\r\n\r\nasync function loadProfile(sub: string) {\r\n  const got = await ddb.send(\r\n    new GetCommand({\r\n      TableName: TABLE_NAME,\r\n      Key: { pk: profilePk(sub), sk: PROFILE_SK },\r\n    }),\r\n  );\r\n\r\n  // If no profile row yet, treat as 0 coins/xp.\r\n  const it = got.Item || {};\r\n  return {\r\n    userId: it.userId || sub,\r\n    coins: Number(it.coins ?? 0),\r\n    xp: Number(it.xp ?? 0),\r\n    level: Number(it.level ?? 1),\r\n    lastEventAt: (it.lastEventAt as string | undefined) ?? null,\r\n  };\r\n}\r\n\r\n// isEpisodeEarlyAccess result shape (matches your earlier idea)\r\nfunction buildEarlyAccessResult(epItem: any, now: Date) {\r\n  const status = (epItem.status || \"DRAFT\") as string;\r\n  const publicAtIso = epItem.publicAt || new Date().toISOString();\r\n  const publicAt = new Date(publicAtIso);\r\n  const isPublic = status === \"PUBLISHED\" && publicAt.getTime() <= now.getTime();\r\n\r\n  return {\r\n    episodeId: (epItem.id ||\r\n      epItem.episodeId ||\r\n      (epItem.pk || \"\").replace(\"EPISODE#\", \"\")) as string,\r\n    status,\r\n    publicAt: publicAtIso,\r\n    isPublic,\r\n  };\r\n}\r\n\r\n// Handler ---------------------------------------------------\r\n\r\nexport const handler = async (event: AppSyncEvent) => {\r\n  const { fieldName } = event.info;\r\n  const identity = event.identity;\r\n  const now = new Date();\r\n\r\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n  // isEpisodeEarlyAccess(episodeId: ID!): EpisodeAccess!\r\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n  if (fieldName === \"isEpisodeEarlyAccess\") {\r\n    const { episodeId } = event.arguments || {};\r\n    if (!episodeId) throw new Error(\"episodeId is required\");\r\n\r\n    const epItem = await loadEpisode(String(episodeId));\r\n    return buildEarlyAccessResult(epItem, now);\r\n  }\r\n\r\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n  // unlockEpisode(episodeId: ID!): UnlockEpisodeResult!\r\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n  if (fieldName === \"unlockEpisode\") {\r\n    if (!identity?.sub) throw new Error(\"Unauthorized\");\r\n    const userId = identity.sub;\r\n    const { episodeId } = event.arguments || {};\r\n    if (!episodeId) throw new Error(\"episodeId is required\");\r\n    const epId = String(episodeId);\r\n\r\n    // 1) Load episode meta\r\n    const epItem = await loadEpisode(epId);\r\n    const episode = mapEpisode(epItem);\r\n\r\n    // \uD83D\uDD10 Type guard so TS knows `episode` is not null anymore\r\n    if (!episode) {\r\n      throw new Error(`Episode not found for id=${episodeId}`);\r\n    }\r\n\r\n    const cost = Number(episode.unlockCoinCost ?? 0);\r\n    const nowIso = now.toISOString();\r\n\r\n    // 2) Check if already unlocked (idempotent, no double-charge)\r\n    const existing = await ddb.send(\r\n      new GetCommand({\r\n        TableName: TABLE_NAME,\r\n        Key: { pk: profilePk(userId), sk: unlockSk(epId) },\r\n      }),\r\n    );\r\n    if (existing.Item) {\r\n      const profile = await loadProfile(userId);\r\n      return {\r\n        success: true,\r\n        unlockedAt: existing.Item.unlockedAt || nowIso,\r\n        costCoins: Number(existing.Item.costCoins ?? 0),\r\n        episode,\r\n        remainingCoins: profile.coins,\r\n      };\r\n    }\r\n\r\n    // 3) If cost > 0, deduct coins from profile with a guard\r\n    let remainingCoins: number;\r\n    if (cost > 0) {\r\n      const upd = await ddb\r\n        .send(\r\n          new UpdateCommand({\r\n            TableName: TABLE_NAME,\r\n            Key: { pk: profilePk(userId), sk: PROFILE_SK },\r\n            UpdateExpression:\r\n              \"SET coins = if_not_exists(coins, :z) - :c, lastEventAt = :now\",\r\n            ConditionExpression:\r\n              \"if_not_exists(coins, :z) >= :c\",\r\n            ExpressionAttributeValues: {\r\n              \":z\": 0,\r\n              \":c\": cost,\r\n              \":now\": nowIso,\r\n            },\r\n            ReturnValues: \"ALL_NEW\",\r\n          }),\r\n        )\r\n        .catch((err) => {\r\n          if (String(err).includes(\"ConditionalCheckFailed\")) {\r\n            throw new Error(\"Not enough coins to unlock this episode.\");\r\n          }\r\n          throw err;\r\n        });\r\n\r\n      remainingCoins = Number(upd.Attributes?.coins ?? 0);\r\n    } else {\r\n      // free unlock\r\n      const profile = await loadProfile(userId);\r\n      remainingCoins = profile.coins;\r\n    }\r\n\r\n    // 4) Write unlock record\r\n    await ddb.send(\r\n      new PutCommand({\r\n        TableName: TABLE_NAME,\r\n        Item: {\r\n          pk: profilePk(userId),\r\n          sk: unlockSk(epId),\r\n          type: \"EPISODE_UNLOCK\",\r\n          episodeId: epId,\r\n          costCoins: cost,\r\n          unlockedAt: nowIso,\r\n          source: \"COIN_UNLOCK\",\r\n        },\r\n        ConditionExpression: \"attribute_not_exists(pk)\",\r\n      }),\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      unlockedAt: nowIso,\r\n      costCoins: cost,\r\n      episode,\r\n      remainingCoins,\r\n    };\r\n  }\r\n\r\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n  // myUnlockedEpisodes: [EpisodeUnlock!]!\r\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n  if (fieldName === \"myUnlockedEpisodes\") {\r\n    if (!identity?.sub) throw new Error(\"Unauthorized\");\r\n    const userId = identity.sub;\r\n\r\n    // List unlock rows\r\n    const out = await ddb.send(\r\n      new QueryCommand({\r\n        TableName: TABLE_NAME,\r\n        KeyConditionExpression: \"pk = :p AND begins_with(sk, :pref)\",\r\n        ExpressionAttributeValues: {\r\n          \":p\": profilePk(userId),\r\n          \":pref\": \"EP_UNLOCK#\",\r\n        },\r\n      }),\r\n    );\r\n\r\n    const unlocks = out.Items || [];\r\n    if (!unlocks.length) return [];\r\n\r\n    // Fetch all episodes in parallel\r\n    const episodesMap = new Map<string, any>();\r\n    await Promise.all(\r\n      unlocks.map(async (u) => {\r\n        const epId = String(u.episodeId || String(u.sk).replace(\"EP_UNLOCK#\", \"\"));\r\n        if (episodesMap.has(epId)) return;\r\n        try {\r\n          const got = await ddb.send(\r\n            new GetCommand({\r\n              TableName: TABLE_NAME,\r\n              Key: { pk: episodePk(epId), sk: EP_SK },\r\n            }),\r\n          );\r\n          if (got.Item) {\r\n            episodesMap.set(epId, mapEpisode(got.Item));\r\n          }\r\n        } catch {\r\n          // ignore missing\r\n        }\r\n      }),\r\n    );\r\n\r\n    return unlocks.map((u) => {\r\n      const epId = String(u.episodeId || String(u.sk).replace(\"EP_UNLOCK#\", \"\"));\r\n      return {\r\n        episodeId: epId,\r\n        unlockedAt: u.unlockedAt || new Date().toISOString(),\r\n        costCoins: Number(u.costCoins ?? 0),\r\n        source: u.source || null,\r\n        episode: episodesMap.get(epId) || null,\r\n      };\r\n    });\r\n  }\r\n\r\n  throw new Error(`Unknown field ${fieldName}`);\r\n};\r\n\r\n\r\n", "// lambda/_shared/env.ts\r\nexport const TABLE_NAME =\r\n  process.env.TABLE_NAME ??\r\n  process.env.APP_TABLE ??\r\n  process.env.TABLE ??\r\n  \"\";\r\n\r\nif (!TABLE_NAME) {\r\n  // Fail fast at cold start so you notice during deploy/tests\r\n  throw new Error(\r\n    \"Missing DynamoDB table env. Provide TABLE_NAME (or APP_TABLE / TABLE).\"\r\n  );\r\n}\r\n"],
  "mappings": "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",
  "names": ["gate_exports", "__export", "handler", "__toCommonJS", "import_client_dynamodb", "import_lib_dynamodb", "TABLE_NAME", "ddb", "episodePk", "id", "EP_SK", "profilePk", "sub", "PROFILE_SK", "unlockSk", "epId", "mapEpisode", "it", "loadEpisode", "episodeId", "got", "TABLE_NAME", "loadProfile", "buildEarlyAccessResult", "epItem", "now", "status", "publicAtIso", "publicAt", "isPublic", "handler", "event", "fieldName", "identity", "userId", "episode", "cost", "nowIso", "existing", "profile", "remainingCoins", "upd", "err", "unlocks", "episodesMap", "u"]
}
