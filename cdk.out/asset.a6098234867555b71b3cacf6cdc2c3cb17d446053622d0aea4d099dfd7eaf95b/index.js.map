{
  "version": 3,
  "sources": ["../../lambda/game/profile.ts"],
  "sourcesContent": ["// lambda/game/profile.ts\r\nimport { DynamoDBClient } from \"@aws-sdk/client-dynamodb\";\r\nimport {\r\n  DynamoDBDocumentClient,\r\n  GetCommand,\r\n  UpdateCommand,\r\n} from \"@aws-sdk/lib-dynamodb\";\r\nimport { AppSyncIdentityCognito } from \"aws-lambda\";\r\n\r\nconst TABLE = process.env.TABLE_NAME!;\r\nconst ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}), {\r\n  marshallOptions: { removeUndefinedValues: true },\r\n});\r\n\r\ntype SAIdentity = (AppSyncIdentityCognito & { groups?: string[] | null }) | null | undefined;\r\n\r\nexport const handler = async (event: any) => {\r\n  const { fieldName } = event.info;\r\n  const identity = event.identity as SAIdentity;\r\n\r\n  if (fieldName === \"getMyProfile\") {\r\n    const sub = identity?.sub;\r\n    if (!sub) throw new Error(\"Unauthenticated\");\r\n\r\n    const got = await ddb.send(new GetCommand({ TableName: TABLE, Key: { pk: `USER#${sub}`, sk: \"PROFILE\" } }));\r\n    const i = got.Item || { pk: `USER#${sub}`, sk: \"PROFILE\", xp: 0, coins: 0, level: 1, badges: [] };\r\n    return {\r\n      userId: sub,\r\n      level: i.level ?? 1,\r\n      xp: i.xp ?? 0,\r\n      coins: i.coins ?? 0,\r\n      badges: Array.isArray(i.badges) ? i.badges : [],\r\n      lastEventAt: i.lastEventAt ?? null,\r\n    };\r\n  }\r\n\r\n  if (fieldName === \"grantBadge\") {\r\n    const { userId, badge } = event.arguments as { userId: string; badge: string };\r\n    // append badge; for uniqueness you could read->dedupe, but simple append is fine for now\r\n    const upd = await ddb.send(new UpdateCommand({\r\n      TableName: TABLE,\r\n      Key: { pk: `USER#${userId}`, sk: \"PROFILE\" },\r\n      UpdateExpression: \"SET badges = list_append(if_not_exists(badges, :empty), :b)\",\r\n      ExpressionAttributeValues: {\r\n        \":empty\": [],\r\n        \":b\": [badge],\r\n      },\r\n      ReturnValues: \"ALL_NEW\",\r\n    }));\r\n    const a = upd.Attributes || {};\r\n    return {\r\n      userId,\r\n      level: a.level ?? 1,\r\n      xp: a.xp ?? 0,\r\n      coins: a.coins ?? 0,\r\n      badges: Array.isArray(a.badges) ? a.badges : [],\r\n      lastEventAt: a.lastEventAt ?? null,\r\n    };\r\n  }\r\n\r\n  throw new Error(\"Unknown field\");\r\n};\r\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GACA,IAAAI,EAA+B,oCAC/BC,EAIO,iCAGDC,EAAQ,QAAQ,IAAI,WACpBC,EAAM,yBAAuB,KAAK,IAAI,iBAAe,CAAC,CAAC,EAAG,CAC9D,gBAAiB,CAAE,sBAAuB,EAAK,CACjD,CAAC,EAIYL,EAAU,MAAOM,GAAe,CAC3C,GAAM,CAAE,UAAAC,CAAU,EAAID,EAAM,KACtBE,EAAWF,EAAM,SAEvB,GAAIC,IAAc,eAAgB,CAChC,IAAME,EAAMD,GAAU,IACtB,GAAI,CAACC,EAAK,MAAM,IAAI,MAAM,iBAAiB,EAG3C,IAAMC,GADM,MAAML,EAAI,KAAK,IAAI,aAAW,CAAE,UAAWD,EAAO,IAAK,CAAE,GAAI,QAAQK,CAAG,GAAI,GAAI,SAAU,CAAE,CAAC,CAAC,GAC5F,MAAQ,CAAE,GAAI,QAAQA,CAAG,GAAI,GAAI,UAAW,GAAI,EAAG,MAAO,EAAG,MAAO,EAAG,OAAQ,CAAC,CAAE,EAChG,MAAO,CACL,OAAQA,EACR,MAAOC,EAAE,OAAS,EAClB,GAAIA,EAAE,IAAM,EACZ,MAAOA,EAAE,OAAS,EAClB,OAAQ,MAAM,QAAQA,EAAE,MAAM,EAAIA,EAAE,OAAS,CAAC,EAC9C,YAAaA,EAAE,aAAe,IAChC,CACF,CAEA,GAAIH,IAAc,aAAc,CAC9B,GAAM,CAAE,OAAAI,EAAQ,MAAAC,CAAM,EAAIN,EAAM,UAY1BO,GAVM,MAAMR,EAAI,KAAK,IAAI,gBAAc,CAC3C,UAAWD,EACX,IAAK,CAAE,GAAI,QAAQO,CAAM,GAAI,GAAI,SAAU,EAC3C,iBAAkB,8DAClB,0BAA2B,CACzB,SAAU,CAAC,EACX,KAAM,CAACC,CAAK,CACd,EACA,aAAc,SAChB,CAAC,CAAC,GACY,YAAc,CAAC,EAC7B,MAAO,CACL,OAAAD,EACA,MAAOE,EAAE,OAAS,EAClB,GAAIA,EAAE,IAAM,EACZ,MAAOA,EAAE,OAAS,EAClB,OAAQ,MAAM,QAAQA,EAAE,MAAM,EAAIA,EAAE,OAAS,CAAC,EAC9C,YAAaA,EAAE,aAAe,IAChC,CACF,CAEA,MAAM,IAAI,MAAM,eAAe,CACjC",
  "names": ["profile_exports", "__export", "handler", "__toCommonJS", "import_client_dynamodb", "import_lib_dynamodb", "TABLE", "ddb", "event", "fieldName", "identity", "sub", "i", "userId", "badge", "a"]
}
