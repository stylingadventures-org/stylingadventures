{
  "version": 3,
  "sources": ["../../lambda/roles/index.ts"],
  "sourcesContent": ["// lambda/roles/index.ts\r\nimport { DynamoDBClient } from \"@aws-sdk/client-dynamodb\";\r\nimport {\r\n  DynamoDBDocumentClient,\r\n  GetCommand,\r\n  PutCommand,\r\n  ScanCommand,\r\n} from \"@aws-sdk/lib-dynamodb\";\r\nimport type {\r\n  AppSyncResolverEvent,\r\n  AppSyncIdentityCognito,\r\n} from \"aws-lambda\";\r\n\r\nconst TABLE_NAME = process.env.TABLE_NAME!;\r\nconst PK_NAME = (process.env.PK_NAME || \"id\").trim() || \"id\"; // default id-only table\r\nconst SK_NAME = (process.env.SK_NAME || \"\").trim();           // if non-empty -> pk/sk layout\r\n\r\nconst ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}));\r\n\r\ntype Role = \"FAN\" | \"BESTIE\" | \"CREATOR\" | \"COLLAB\" | \"ADMIN\";\r\ntype Tier = \"FREE\" | \"PRIME\";\r\n\r\ninterface User {\r\n  id: string;\r\n  email?: string | null;\r\n  role: Role;\r\n  tier?: Tier | null;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\nconst nowIso = () => new Date().toISOString();\r\n\r\n/* -------------------------------------------------- */\r\n/* Key helpers: support id-only or pk/sk              */\r\n/* -------------------------------------------------- */\r\nfunction keyFor(sub: string) {\r\n  if (!SK_NAME) return { [PK_NAME]: sub }; // id-only\r\n  return { [PK_NAME]: `USER#${sub}`, [SK_NAME]: \"PROFILE\" };\r\n}\r\n\r\nfunction putItemFor(\r\n  sub: string,\r\n  payload: Omit<User, \"id\"> & { id?: string }\r\n) {\r\n  const base: any = {\r\n    id: sub,\r\n    email: payload.email ?? null,\r\n    role: payload.role,\r\n    tier: payload.tier ?? null,\r\n    createdAt: payload.createdAt,\r\n    updatedAt: payload.updatedAt,\r\n  };\r\n\r\n  if (!SK_NAME) {\r\n    base[PK_NAME] = sub; // id-only PK\r\n  } else {\r\n    base[PK_NAME] = `USER#${sub}`;\r\n    base[SK_NAME] = \"PROFILE\";\r\n  }\r\n  return base;\r\n}\r\n\r\n/* Normalizes a raw row to the GraphQL User */\r\nfunction toUser(sub: string, raw: any): User {\r\n  return {\r\n    id: sub,\r\n    email: (raw?.email ?? null) as string | null,\r\n    role: (raw?.role as Role) || \"FAN\",\r\n    tier: (raw?.tier as Tier) ?? null,\r\n    createdAt: (raw?.createdAt as string) ?? nowIso(),\r\n    updatedAt: (raw?.updatedAt as string) ?? nowIso(),\r\n  };\r\n}\r\n\r\n/* Load row (if any) */\r\nasync function loadUser(sub: string) {\r\n  const got = await ddb.send(\r\n    new GetCommand({\r\n      TableName: TABLE_NAME,\r\n      Key: keyFor(sub),\r\n    })\r\n  );\r\n  return got.Item || null;\r\n}\r\n\r\n/* Upsert row */\r\nasync function upsertUser(sub: string, item: User, conditionalCreate = false) {\r\n  const put = new PutCommand({\r\n    TableName: TABLE_NAME,\r\n    Item: putItemFor(sub, item),\r\n    ...(conditionalCreate\r\n      ? !SK_NAME\r\n        ? {\r\n            ConditionExpression: \"attribute_not_exists(#pk)\",\r\n            ExpressionAttributeNames: { \"#pk\": PK_NAME },\r\n          }\r\n        : {\r\n            ConditionExpression:\r\n              \"attribute_not_exists(#pk) AND attribute_not_exists(#sk)\",\r\n            ExpressionAttributeNames: { \"#pk\": PK_NAME, \"#sk\": SK_NAME },\r\n          }\r\n      : undefined),\r\n  });\r\n\r\n  return ddb.send(put);\r\n}\r\n\r\n/* -------------------------------------------------- */\r\n/* Resolver                                           */\r\n/* -------------------------------------------------- */\r\nexport const handler = async (event: AppSyncResolverEvent<any>) => {\r\n  const field = event.info.fieldName;\r\n\r\n  // Cognito identity from AppSync\r\n  const ident = event.identity as AppSyncIdentityCognito | undefined;\r\n  const sub = ident?.sub;\r\n  const email = (ident as any)?.claims?.email as string | undefined;\r\n  const groups = (ident as any)?.claims?.[\"cognito:groups\"];\r\n  const isAdmin = Array.isArray(groups)\r\n    ? groups.includes(\"ADMIN\")\r\n    : `${groups || \"\"}`.includes(\"ADMIN\");\r\n\r\n  /* ============================= me ============================= */\r\n  if (field === \"me\") {\r\n    if (!sub) throw new Error(\"Unauthenticated\");\r\n\r\n    const found = await loadUser(sub);\r\n    if (found) return toUser(sub, found);\r\n\r\n    // Create default FAN profile idempotently\r\n    const now = nowIso();\r\n    const newUser: User = {\r\n      id: sub,\r\n      email: email?.toLowerCase?.() ?? null,\r\n      role: \"FAN\",\r\n      tier: \"FREE\",\r\n      createdAt: now,\r\n      updatedAt: now,\r\n    };\r\n\r\n    try {\r\n      await upsertUser(sub, newUser, true);\r\n    } catch {\r\n      // race: if it already exists, ignore\r\n    }\r\n\r\n    // Read back to return actual stored row (covers race)\r\n    const readBack = await loadUser(sub);\r\n    return readBack ? toUser(sub, readBack) : newUser;\r\n  }\r\n\r\n  /* ========================= setUserRole ======================== */\r\n  if (field === \"setUserRole\") {\r\n    if (!sub) throw new Error(\"Unauthenticated\");\r\n\r\n    const input = event.arguments?.input as {\r\n      userId: string;\r\n      email?: string | null;\r\n      role: Role;\r\n      tier?: Tier | null;\r\n    };\r\n\r\n    if (!input?.userId || !input?.role) {\r\n      throw new Error(\"userId and role are required\");\r\n    }\r\n\r\n    const targetUserId = input.userId;\r\n\r\n    // Only ADMIN can modify others; anyone can modify self\r\n    if (!isAdmin && targetUserId !== sub) {\r\n      throw new Error(\"Not authorized to modify other users\");\r\n    }\r\n\r\n    const existing = await loadUser(targetUserId);\r\n    const now = nowIso();\r\n\r\n    const merged: User = existing\r\n      ? {\r\n          ...toUser(targetUserId, existing),\r\n          email:\r\n            (input.email ??\r\n              (existing as any).email ??\r\n              null)?.toLowerCase?.() ?? null,\r\n          role: input.role,\r\n          tier: input.tier ?? (existing as any).tier ?? null,\r\n          updatedAt: now,\r\n        }\r\n      : {\r\n          id: targetUserId,\r\n          email: (input.email ?? null)?.toLowerCase?.() ?? null,\r\n          role: input.role,\r\n          tier: input.tier ?? \"FREE\",\r\n          createdAt: now,\r\n          updatedAt: now,\r\n        };\r\n\r\n    await upsertUser(targetUserId, merged, false);\r\n    return merged;\r\n  }\r\n\r\n  /* ======================== adminListUsers ====================== */\r\n  if (field === \"adminListUsers\") {\r\n    if (!isAdmin) throw new Error(\"Not authorized\");\r\n\r\n    const args = (event.arguments || {}) as {\r\n      search?: string | null;\r\n      limit?: number | null;\r\n      nextToken?: string | null;\r\n    };\r\n\r\n    const limit = Math.min(Math.max(args.limit ?? 25, 1), 100);\r\n    const startKey = args.nextToken\r\n      ? JSON.parse(Buffer.from(args.nextToken, \"base64\").toString(\"utf8\"))\r\n      : undefined;\r\n\r\n    const q = (args.search || \"\").trim().toLowerCase();\r\n\r\n    // Build a Scan that works in both layouts.\r\n    // For pk/sk: keep only profile rows (pk begins_with 'USER#' and sk='PROFILE').\r\n    // For id-only: no special filter needed.\r\n    const params: any = {\r\n      TableName: TABLE_NAME,\r\n      Limit: limit,\r\n      ExclusiveStartKey: startKey,\r\n    };\r\n\r\n    const names: Record<string, string> = {};\r\n    const values: Record<string, any> = {};\r\n    const filters: string[] = [];\r\n\r\n    if (SK_NAME) {\r\n      names[\"#pk\"] = PK_NAME;\r\n      names[\"#sk\"] = SK_NAME;\r\n      values[\":u\"] = \"USER#\";\r\n      values[\":p\"] = \"PROFILE\";\r\n      filters.push(\"begins_with(#pk, :u) AND #sk = :p\");\r\n    }\r\n\r\n    if (q) {\r\n      names[\"#email\"] = \"email\";\r\n      values[\":q\"] = q;\r\n      filters.push(\"contains(#email, :q)\");\r\n    }\r\n\r\n    if (filters.length) {\r\n      params.FilterExpression = filters.join(\" AND \");\r\n      params.ExpressionAttributeNames = names;\r\n      params.ExpressionAttributeValues = values;\r\n    }\r\n\r\n    const out = await ddb.send(new ScanCommand(params));\r\n\r\n    const items = (out.Items || []).map((raw: any) => {\r\n      // when pk/sk, the actual user id is embedded in pk\r\n      let uid = raw?.id;\r\n      if (!uid && SK_NAME && typeof raw?.[PK_NAME] === \"string\") {\r\n        const m = String(raw[PK_NAME]).match(/^USER#(.+)$/);\r\n        if (m) uid = m[1];\r\n      }\r\n      return toUser(uid || raw?.id, raw);\r\n    });\r\n\r\n    return {\r\n      items,\r\n      nextToken: out.LastEvaluatedKey\r\n        ? Buffer.from(JSON.stringify(out.LastEvaluatedKey)).toString(\"base64\")\r\n        : null,\r\n    };\r\n  }\r\n\r\n  /* =========================== default ========================== */\r\n  throw new Error(`Unhandled field: ${field}`);\r\n};\r\n"],
  "mappings": "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",
  "names": ["roles_exports", "__export", "handler", "__toCommonJS", "import_client_dynamodb", "import_lib_dynamodb", "TABLE_NAME", "PK_NAME", "SK_NAME", "ddb", "nowIso", "keyFor", "sub", "putItemFor", "payload", "base", "toUser", "raw", "loadUser", "upsertUser", "item", "conditionalCreate", "put", "event", "field", "ident", "email", "groups", "isAdmin", "found", "now", "newUser", "readBack", "input", "targetUserId", "existing", "merged", "args", "limit", "startKey", "q", "params", "names", "values", "filters", "out", "uid", "m"]
}
