<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Styling Adventures</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="/styles.css" />
  <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
  <link rel="alternate icon" href="/favicon.ico" />

  <!-- Small page-specific CSS (no inline style warnings) -->
  <style>
    /* Dropzone */
    #dropzone.dz {
      padding: 20px;
      border: 2px dashed #bbb;
      border-radius: 10px;
      transition: border-color .15s ease;
    }
    #dropzone.dz.dragover { border-color: #666; }

    /* Upload rows */
    .li-row { margin: 6px 0; }
    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .row strong { min-width:220px; word-break:break-all; }
    .row .size { min-width:90px; }
    .row .ctype { min-width:150px; }
    .row progress { width:220px; }
    .row .status { min-width:120px; }
    .ml-auto { margin-left:auto; }
    .hidden { display:none; }
    .error { color: #b00020; }
  </style>
</head>
<body class="sa-body">
  <h1>StylingAdventures</h1>

  <div class="actions">
    <a id="signin" href="#" class="sa-link">Sign in</a>
    <button id="signout" class="sa-btn sa-btn-outline ml-2">Sign out</button>
    <button id="signout-global" class="sa-btn sa-btn-outline ml-2">Sign out everywhere</button>
  </div>

  <h2>Status</h2>
  <div id="status" class="sa-card">Loading…</div>
  <button id="refresh-now" class="sa-btn mt-2" aria-label="Refresh tokens now">Refresh tokens now</button>

  <h3>Debug</h3>
  <pre id="dbg" class="sa-pre sa-muted"></pre>

  <!-- AppSync hello -->
  <h2>AppSync hello</h2>
  <div class="sa-card">
    <button id="btn-hello" class="sa-btn">Call { hello }</button>
    <span id="hello-out" class="ml-2 sa-muted" aria-live="polite"></span>
  </div>

  <!-- Uploads -->
  <h2>Uploads</h2>
  <div class="sa-card">
    <div class="form-row">
      <label for="upload-key" class="sa-label">Key prefix (optional)</label>
      <input id="upload-key" name="key" placeholder="e.g. photos/2025/" class="sa-input" />
    </div>

    <div class="form-row">
      <label for="upload-file" class="sa-label">Files</label>
      <input id="upload-file" name="file" type="file" multiple class="sa-input" />
    </div>

    <!-- Drag & Drop area -->
    <div id="dropzone" class="sa-card sa-muted dz">
      Drag & drop files here, or use the file picker above.
    </div>

    <button id="btn-upload" class="sa-btn mt-2" aria-label="Upload file(s) and list existing uploads">
      Upload selected files
    </button>

    <p id="uploads-msg" class="sa-muted mt-2" aria-live="polite"></p>

    <!-- Rendered list with per-item progress + delete -->
    <ul id="upload-list" class="sa-muted mt-2"></ul>
  </div>

  <script type="module">
    // ===== config / helpers =====
    const cfg = await fetch(`/config.json?ts=${Date.now()}`, { cache: 'no-store' }).then(r => r.json());
    const domain = `https://${cfg.domain}.auth.${cfg.region}.amazoncognito.com`;
    const authorizeUrl = `${domain}/oauth2/authorize`;
    const logoutUrl = `${domain}/logout?client_id=${encodeURIComponent(cfg.clientId)}&logout_uri=${encodeURIComponent(cfg.logoutUri)}`;
    const api = cfg.uploadsUrl.replace(/\/+$/, '');

    const $ = s => document.querySelector(s);
    const enc = new TextEncoder();
    const MAX_MB = 50;
    const ALLOW_TYPES = ['text/plain','image/png','image/jpeg','image/gif','application/pdf','video/mp4'];
    const CONCURRENCY = 4;

    const MIME_BY_EXT = {
      png:'image/png', jpg:'image/jpeg', jpeg:'image/jpeg', gif:'image/gif',
      pdf:'application/pdf', txt:'text/plain', mp4:'video/mp4'
    };

    function base64Url(uint8){ return btoa(String.fromCharCode(...uint8)).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); }
    function randBytes(n){ const a=new Uint8Array(n); crypto.getRandomValues(a); return a; }
    function randomString(n=32){ return base64Url(randBytes(n)); }
    async function sha256(s){ const h=await crypto.subtle.digest('SHA-256', enc.encode(s)); return new Uint8Array(h); }

    const prettySize = b => {
      if (b == null) return '';
      const u = ['B','KB','MB','GB','TB']; let i = 0, n = Number(b);
      while (n >= 1024 && i < u.length-1){ n/=1024; i++; }
      return `${n.toFixed(n<10 && i>0 ? 1 : 0)} ${u[i]}`;
    };
    const inferTypeFromKey = (key) => {
      const m = key.toLowerCase().match(/\.([a-z0-9]+)$/); const ext = m?.[1] || '';
      return MIME_BY_EXT[ext] || 'application/octet-stream';
    };

    function sanitizePrefix(raw) {
      let s = (raw || '').trim();
      if (!s) return '';
      if (s.includes('..')) throw new Error('Prefix cannot contain ".."');
      s = s.replace(/^\/*/, '').replace(/\/+$/, '');       // trim slashes
      s = s.replace(/[^A-Za-z0-9_\-\/]/g, '');             // safe chars only
      if (!s) return '';
      return s + '/';                                      // ensure trailing slash
    }

    function toast(text, type='info'){
      const el = $('#uploads-msg');
      el.textContent = text;
      el.className = `sa-muted mt-2 ${type==='error' ? 'sa-error' : ''}`;
    }

    // ===== auth bits =====
    async function startLogin(){
      const verifier = randomString(64);
      sessionStorage.setItem('pkce_verifier', verifier);
      const challenge = base64Url(await sha256(verifier));
      const state = randomString(24);
      sessionStorage.setItem('oauth_state', state);
      const url = new URL(authorizeUrl);
      url.searchParams.set('response_type','code');
      url.searchParams.set('client_id', cfg.clientId);
      url.searchParams.set('redirect_uri', cfg.redirectUri);
      url.searchParams.set('scope','openid email profile');
      url.searchParams.set('code_challenge', challenge);
      url.searchParams.set('code_challenge_method','S256');
      url.searchParams.set('state', state);
      location.assign(url.toString());
    }

    function signOutLocal(){ sessionStorage.clear(); render(); }

    async function signOutEverywhere(){
      try{
        const refresh = sessionStorage.getItem('refresh_token') || (JSON.parse(sessionStorage.getItem('tokens')||'{}').refresh_token);
        if (refresh){
          const body = new URLSearchParams({ token: refresh, token_type_hint:'refresh_token', client_id: cfg.clientId });
          await fetch(`${domain}/oauth2/revoke`, { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body }).catch(()=>{});
        }
      } finally {
        sessionStorage.clear();
        location.replace(logoutUrl);
      }
    }

    function parseJwt(t){ if(!t) return null; try{ return JSON.parse(atob(t.split('.')[1].replace(/-/g,'+').replace(/_/g,'/')));}catch{return null;} }
    function secondsLeft(id){ const p=parseJwt(id); return p?.exp ? Math.max(0, p.exp - Math.floor(Date.now()/1000)) : 0; }

    // ✅ Ensure we have a fresh ID token (refresh if < 60s left)
    async function ensureFreshIdToken(minSeconds=60){
      let id = sessionStorage.getItem('id_token');
      if (!id) return null;
      if (secondsLeft(id) > minSeconds) return id;
      const { refreshTokens, scheduleRotation } = await import('/auth/refresh.js');
      const out = await refreshTokens({ domain, clientId: cfg.clientId });
      scheduleRotation(out, { domain, clientId: cfg.clientId });
      render();
      return out.id_token || sessionStorage.getItem('id_token');
    }

    function render(){
      const id = sessionStorage.getItem('id_token');
      $('#signin').style.display = id ? 'none' : 'inline';
      $('#signout').style.display = id ? 'inline-block' : 'none';
      $('#signout-global').style.display = id ? 'inline-block' : 'none';
      const left = secondsLeft(id);
      const mins = Math.floor(left/60);
      const secs = String(left%60).padStart(2,'0');
      $('#status').textContent = id
        ? `Signed in · token refreshes in ${mins}:${secs}`
        : 'You’re signed out. Click “Sign in” to start.';
      $('#dbg').textContent = id ? JSON.stringify(parseJwt(id) || {}, null, 2) : '';
    }

    // ===== AppSync { hello } =====
    async function callHello(){
      const id = await ensureFreshIdToken();
      if (!id){ alert('Please sign in first'); return; }
      const res = await fetch(cfg.appsyncUrl,{
        method:'POST',
        headers:{ 'Content-Type':'application/json', 'Authorization': id },
        body: JSON.stringify({ query: `query Hello { hello }` })
      });
      if (!res.ok) throw new Error(`AppSync ${res.status}: ${await res.text()}`);
      const json = await res.json();
      $('#hello-out').textContent = json.data?.hello ?? '(no data)';
    }

    // ===== list + delete (human size + inferred type) =====
    function liRow(displayName, sizeText, typeText){
      const li = document.createElement('li');
      li.className = 'li-row';
      li.innerHTML = `
        <div class="row">
          <strong>${displayName}</strong>
          <span class="sa-muted size">${sizeText||''}</span>
          <span class="sa-muted ctype">${typeText||''}</span>
          <progress max="100" value="0" class="row-progress"></progress>
          <span class="sa-muted status"></span>
          <button class="sa-btn sa-btn-outline sa-sm delete ml-auto hidden" disabled>Delete</button>
        </div>
      `;
      return li;
    }

    async function listUploads(){
      const id = sessionStorage.getItem('id_token');
      if (!id) return;
      const res = await fetch(`${api}/list`, { headers:{ Authorization: id }});
      if (!res.ok) return;
      const data = await res.json();
      const items = Array.isArray(data) ? data : (data.items ?? data.keys ?? []);
      const ul = $('#upload-list');
      ul.innerHTML = '';

      items.forEach(rec => {
        const key = typeof rec === 'string' ? rec : rec.key;
        const sizeText = typeof rec === 'string' ? '' : prettySize(rec.size);
        const typeText = inferTypeFromKey(key);
        const li = liRow(key, sizeText, typeText);
        const prog = li.querySelector('.row-progress');
        const status = li.querySelector('.status');
        const delBtn = li.querySelector('.delete');

        if (prog instanceof HTMLElement) prog.style.display = 'none';
        if (status) status.textContent = '';

        if (delBtn instanceof HTMLButtonElement) {
          delBtn.classList.remove('hidden');
          delBtn.disabled = false;
          delBtn.addEventListener('click', async () => {
            if (!confirm(`Delete "${key}"?`)) return;
            const idTok = await ensureFreshIdToken();
            delBtn.disabled = true;
            const r = await fetch(`${api}/delete?key=${encodeURIComponent(key)}`, { method:'DELETE', headers:{ Authorization: idTok }});
            if (!r.ok){ alert(`Delete failed: ${r.status} ${await r.text()}`); delBtn.disabled = false; return; }
            li.remove();
          });
        }

        ul.appendChild(li);
      });
    }

    // ===== API helpers =====
    async function presign(id, key, type){
      const r = await fetch(`${api}/presign`, {
        method:'POST',
        headers:{ Authorization: id, 'Content-Type':'application/json' },
        body: JSON.stringify({ key, contentType: type || 'application/octet-stream' })
      });
      const txt = await r.text();
      let json; try{ json = JSON.parse(txt); }catch{}
      if (!r.ok || !json?.url) throw new Error(`presign ${r.status}: ${txt}`);
      return json;
    }

    async function requestThumbnail(key){
      try{
        const idTok = await ensureFreshIdToken();
        await fetch(`${api}/thumb`, {
          method:'POST',
          headers:{ Authorization: idTok, 'Content-Type':'application/json' },
          body: JSON.stringify({ key })
        });
      }catch{}
    }

    // ===== DnD =====
    const drop = $('#dropzone');
    ['dragenter','dragover','dragleave','drop'].forEach(ev=>{
      drop.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); }, false);
    });
    drop.addEventListener('dragover', () => drop.classList.add('dragover'));
    drop.addEventListener('dragleave', () => drop.classList.remove('dragover'));
    drop.addEventListener('drop', e => {
      drop.classList.remove('dragover');
      const files = [...(e.dataTransfer?.files || [])];
      if (files.length) startUpload(files);
    });

    // ===== uploads: prefix polish + multi + progress + delete-disable + thumbnail hook =====
    async function startUpload(filesArg){
      const fileInput = document.getElementById('upload-file');
      const prefixInput = document.getElementById('upload-key');

      if (!(fileInput instanceof HTMLInputElement) || !(prefixInput instanceof HTMLInputElement)) {
        toast('Upload controls not found on page', 'error');
        return;
      }

      let prefix = '';
      try { prefix = sanitizePrefix(prefixInput.value); }
      catch (err){ toast((err && err.message) || String(err), 'error'); return; }

      const files = filesArg ?? [...(fileInput.files || [])];
      if (!files.length){ toast('Pick or drop some files to upload.', 'error'); return; }

      // validate
      for (const f of files){
        if (f.size > MAX_MB*1024*1024){ toast(`"${f.name}" is too large (max ${MAX_MB} MB)`, 'error'); return; }
        if (ALLOW_TYPES.length && !ALLOW_TYPES.includes(f.type) &&
            !ALLOW_TYPES.some(t => t.endsWith('/*') && f.type.startsWith(t.slice(0,-1)))){
          toast(`"${f.name}": type not allowed (${f.type||'unknown'})`, 'error'); return;
        }
      }

      const id = await ensureFreshIdToken();
      if (!id){ toast('Please sign in first', 'error'); return; }
      const sub = parseJwt(id)?.sub || 'me';

      const ul = $('#upload-list');
      const rows = files.map(f => {
        const relKey = `${prefix}${f.name}`;
        const fullKey = `users/${sub}/${relKey}`;
        const li = liRow(f.name, prettySize(f.size), f.type || inferTypeFromKey(f.name));
        ul.prepend(li);
        const prog = li.querySelector('.row-progress');
        const status = li.querySelector('.status');
        const delBtn = li.querySelector('.delete');
        if (status) status.textContent = 'preparing…';
        if (delBtn instanceof HTMLButtonElement) delBtn.disabled = true;
        return { f, relKey, key: fullKey, li, prog, status, delBtn };
      });

      let active = 0, idx = 0, errors = 0;
      toast(`Uploading ${files.length} file(s)…`);

      await new Promise((done) => {
        const next = async () => {
          if (idx >= rows.length){ if (active===0) done(); return; }
          const row = rows[idx++]; active++;
          try {
            if (row.status) row.status.textContent = 'presigning…';
            const { url, headers } = await presign(id, row.relKey, row.f.type || inferTypeFromKey(row.f.name));

            if (row.status) row.status.textContent = 'uploading…';
            await new Promise((resolve, reject) => {
              const xhr = new XMLHttpRequest();
              xhr.open('PUT', url);
              const hdrs = headers || { 'Content-Type': row.f.type || inferTypeFromKey(row.f.name) };
              Object.entries(hdrs).forEach(([k,v]) => xhr.setRequestHeader(k, String(v)));
              xhr.upload.onprogress = e => {
                if (e.lengthComputable && row.prog instanceof HTMLProgressElement) {
                  row.prog.value = Math.round((e.loaded/e.total)*100);
                }
              };
              xhr.onload = () => (xhr.status>=200 && xhr.status<300) ? resolve(null) : reject(new Error(`S3 PUT ${xhr.status}: ${xhr.responseText}`));
              xhr.onerror = () => reject(new Error('Network error'));
              xhr.send(row.f);
            });

            // mark done
            if (row.status) row.status.textContent = 'done';
            if (row.prog instanceof HTMLElement) row.prog.style.display = 'none';
            if (row.delBtn instanceof HTMLButtonElement) {
              row.delBtn.classList.remove('hidden');
              row.delBtn.disabled = false;
            }

            // enqueue thumbnail job for images (full S3 key)
            if ((row.f.type || '').startsWith('image/')) {
              try {
                await fetch(`${api}/thumb`, {
                  method: 'POST',
                  headers: { Authorization: await ensureFreshIdToken(), 'Content-Type': 'application/json' },
                  body: JSON.stringify({ key: row.key })
                });
              } catch {}
            }
          } catch (e){
            errors++; console.error(e);
            if (row.status) row.status.textContent = 'error';
            row.li.classList.add('error');
            if (row.prog instanceof HTMLElement) row.prog.style.display = 'none';
          } finally {
            active--; next();
          }
        };
        for (let i=0; i<CONCURRENCY && i<rows.length; i++) next();
      });

      if (errors) toast(`Finished with ${errors} error(s)`, 'error'); else toast('All uploads complete ✔');
      await listUploads();
    }

    // ===== wire up =====
    $('#signin').addEventListener('click', e => { e.preventDefault(); startLogin(); });
    $('#signout').addEventListener('click', e => { e.preventDefault(); signOutLocal(); });
    $('#signout-global').addEventListener('click', e => { e.preventDefault(); signOutEverywhere(); });
    $('#btn-hello')?.addEventListener('click', e => { e.preventDefault(); callHello().catch(err => $('#hello-out').textContent = `Error: ${err.message}`); });
    $('#btn-upload')?.addEventListener('click', e => { e.preventDefault(); startUpload().catch(err => alert(err.message)); });

    // Backfill + rotation + manual refresh
    (function backfill(){
      if (!sessionStorage.getItem('tokens')){
        const id = sessionStorage.getItem('id_token');
        const at = sessionStorage.getItem('access_token');
        const rt = sessionStorage.getItem('refresh_token');
        if (id && at && rt) sessionStorage.setItem('tokens', JSON.stringify({ id_token:id, access_token:at, refresh_token:rt, expires_in:3600 }));
      }
    })();
    (async function ensureRotation(){
      const raw = sessionStorage.getItem('tokens'); if (!raw) return;
      const tokens = JSON.parse(raw);
      const { scheduleRotation } = await import('/auth/refresh.js');
      scheduleRotation(tokens, { domain, clientId: cfg.clientId });
    })();
    $('#refresh-now')?.addEventListener('click', async e => {
      e.preventDefault();
      const { refreshTokens, scheduleRotation } = await import('/auth/refresh.js');
      try{
        const out = await refreshTokens({ domain, clientId: cfg.clientId });
        scheduleRotation(out, { domain, clientId: cfg.clientId });
        render();
      }catch(err){ alert(`Refresh failed: ${err.message||err}`); }
    });

    render();
    setInterval(render, 1000);
    if (sessionStorage.getItem('id_token')) listUploads();
  </script>
</body>
</html>