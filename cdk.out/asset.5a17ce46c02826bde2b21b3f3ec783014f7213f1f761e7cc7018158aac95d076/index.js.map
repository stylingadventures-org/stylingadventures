{
  "version": 3,
  "sources": ["../../lambda/prime/publish-episode.ts"],
  "sourcesContent": ["// lambda/prime/publish-episode.ts\r\n\r\n/**\r\n * Prime Studios - Episode Publisher\r\n *\r\n * Role in pipeline:\r\n *  - Final step after validation + layout checks.\r\n *  - Marks an episode as \"published\" and (optionally) writes to a fan-facing feed.\r\n *\r\n * This is kept deliberately generic:\r\n *  - If EPISODE_FEED_TABLE is set, we persist a minimal feed record to DynamoDB.\r\n *  - Otherwise, we just return the transformed payload for Step Functions / API.\r\n */\r\n\r\nimport { DynamoDBClient, PutItemCommand } from \"@aws-sdk/client-dynamodb\";\r\n\r\nconst ddb = new DynamoDBClient({});\r\n\r\nconst EPISODE_FEED_TABLE = process.env.EPISODE_FEED_TABLE; // optional\r\nconst EPISODE_FEED_PK_PREFIX =\r\n  process.env.EPISODE_FEED_PK_PREFIX ?? \"EPISODE#\";\r\nconst EPISODE_FEED_SK_PREFIX =\r\n  process.env.EPISODE_FEED_SK_PREFIX ?? \"VERSION#\";\r\n\r\ntype Severity = \"INFO\" | \"WARNING\" | \"ERROR\";\r\n\r\nexport interface ValidationIssue {\r\n  code: string;\r\n  severity: Severity;\r\n  message: string;\r\n  path?: string;\r\n}\r\n\r\nexport interface EpisodeDocument {\r\n  episodeId?: string;\r\n  slug?: string;\r\n  title?: string;\r\n  status?: string;\r\n  version?: string;\r\n  publishedAt?: string;\r\n  [key: string]: any;\r\n}\r\n\r\nexport interface ValidationSummary {\r\n  ok: boolean;\r\n  issues?: ValidationIssue[];\r\n  [key: string]: any;\r\n}\r\n\r\nexport interface PublishEpisodeEvent {\r\n  /**\r\n   * Episode document, ideally already validated + with layout checklist applied.\r\n   */\r\n  episode: EpisodeDocument;\r\n\r\n  /**\r\n   * Optional validation result from ValidateEpisodeFn.\r\n   * If present and ok === false, we will refuse to publish.\r\n   */\r\n  validation?: ValidationSummary;\r\n\r\n  /**\r\n   * If true, perform no writes; just return what *would* be published.\r\n   */\r\n  dryRun?: boolean;\r\n\r\n  /**\r\n   * Optional override status, e.g. \"scheduled\" instead of \"published\".\r\n   */\r\n  targetStatus?: string;\r\n}\r\n\r\nexport interface PublishedFeedItem {\r\n  episodeId?: string;\r\n  slug?: string;\r\n  title?: string;\r\n  version?: string;\r\n  status: string;\r\n  publishedAt: string;\r\n}\r\n\r\nexport interface PublishEpisodeResult {\r\n  published: boolean;\r\n  status: string;\r\n  episode: EpisodeDocument;\r\n  feedItem?: PublishedFeedItem;\r\n  validation?: ValidationSummary;\r\n  skippedWrite?: boolean;\r\n}\r\n\r\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n// Helpers\r\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nfunction ensureEpisodeIdentity(ep: EpisodeDocument) {\r\n  if (!ep.episodeId && ep.slug) {\r\n    ep.episodeId = ep.slug;\r\n  }\r\n}\r\n\r\n/**\r\n * Derive a version string if none present.\r\n * Very simple: YYYYMMDDHHmmss for now.\r\n */\r\nfunction ensureVersion(ep: EpisodeDocument) {\r\n  if (!ep.version) {\r\n    const now = new Date();\r\n    const pad = (n: number) => n.toString().padStart(2, \"0\");\r\n    const v =\r\n      now.getUTCFullYear().toString() +\r\n      pad(now.getUTCMonth() + 1) +\r\n      pad(now.getUTCDate()) +\r\n      pad(now.getUTCHours()) +\r\n      pad(now.getUTCMinutes()) +\r\n      pad(now.getUTCSeconds());\r\n    ep.version = v;\r\n  }\r\n}\r\n\r\nasync function putFeedRecord(item: PublishedFeedItem): Promise<void> {\r\n  if (!EPISODE_FEED_TABLE) {\r\n    console.log(\r\n      \"EPISODE_FEED_TABLE not set; skipping DynamoDB write, but publish succeeds.\",\r\n    );\r\n    return;\r\n  }\r\n\r\n  const episodeKey = item.episodeId ?? item.slug;\r\n  if (!episodeKey) {\r\n    console.warn(\r\n      \"No episodeId or slug present; skipping DynamoDB write, but publish succeeds.\",\r\n    );\r\n    return;\r\n  }\r\n\r\n  const pk = `${EPISODE_FEED_PK_PREFIX}${episodeKey}`;\r\n  const sk = `${EPISODE_FEED_SK_PREFIX}${item.version}`;\r\n\r\n  console.log(\"Writing episode feed item to DynamoDB:\", {\r\n    table: EPISODE_FEED_TABLE,\r\n    pk,\r\n    sk,\r\n    item,\r\n  });\r\n\r\n  // Simple S-only AttributeValue mapping\r\n  const attributes: any = {\r\n    pk: { S: pk },\r\n    sk: { S: sk },\r\n    type: { S: \"episode#feed\" },\r\n  };\r\n\r\n  for (const [key, value] of Object.entries(item)) {\r\n    if (value === undefined || value === null) continue;\r\n    attributes[key] = { S: String(value) };\r\n  }\r\n\r\n  await ddb.send(\r\n    new PutItemCommand({\r\n      TableName: EPISODE_FEED_TABLE,\r\n      Item: attributes,\r\n    }),\r\n  );\r\n}\r\n\r\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n// Lambda handler\r\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport const handler = async (\r\n  event: PublishEpisodeEvent,\r\n): Promise<PublishEpisodeResult> => {\r\n  console.log(\r\n    \"PublishEpisode incoming event:\",\r\n    JSON.stringify(event, null, 2),\r\n  );\r\n\r\n  if (!event || !event.episode) {\r\n    throw new Error(\"PublishEpisode requires 'episode' in payload.\");\r\n  }\r\n\r\n  // If validation is present and failed, refuse to publish\r\n  if (event.validation && event.validation.ok === false) {\r\n    console.warn(\r\n      \"Refusing to publish: validation.ok === false. Issues:\",\r\n      JSON.stringify(event.validation.issues ?? [], null, 2),\r\n    );\r\n\r\n    const ep: EpisodeDocument = {\r\n      ...event.episode,\r\n      status: event.episode.status ?? \"validation_failed\",\r\n    };\r\n\r\n    return {\r\n      published: false,\r\n      status: ep.status!,\r\n      episode: ep,\r\n      validation: event.validation,\r\n      skippedWrite: true,\r\n    };\r\n  }\r\n\r\n  const nowIso = new Date().toISOString();\r\n  const targetStatus = event.targetStatus ?? \"published\";\r\n\r\n  const episode: EpisodeDocument = {\r\n    status: targetStatus,\r\n    ...event.episode,\r\n    publishedAt: event.episode.publishedAt ?? nowIso,\r\n  };\r\n\r\n  ensureEpisodeIdentity(episode);\r\n  ensureVersion(episode);\r\n\r\n  const feedItem: PublishedFeedItem = {\r\n    episodeId: episode.episodeId,\r\n    slug: episode.slug,\r\n    title: episode.title,\r\n    version: episode.version,\r\n    status: episode.status ?? targetStatus,\r\n    publishedAt: episode.publishedAt!,\r\n  };\r\n\r\n  let skippedWrite = false;\r\n\r\n  if (event.dryRun) {\r\n    console.log(\"Dry-run publish; not writing to any datastore.\");\r\n    skippedWrite = true;\r\n  } else {\r\n    try {\r\n      await putFeedRecord(feedItem);\r\n    } catch (err) {\r\n      console.error(\"Error writing episode feed record:\", err);\r\n      // Surface the error so Step Functions can decide retry / DLQ.\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  const result: PublishEpisodeResult = {\r\n    published: true,\r\n    status: episode.status ?? targetStatus,\r\n    episode,\r\n    feedItem,\r\n    validation: event.validation,\r\n    skippedWrite,\r\n  };\r\n\r\n  console.log(\"PublishEpisode result:\", JSON.stringify(result, null, 2));\r\n\r\n  return result;\r\n};\r\n"],
  "mappings": "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",
  "names": ["publish_episode_exports", "__export", "handler", "__toCommonJS", "import_client_dynamodb", "ddb", "EPISODE_FEED_TABLE", "EPISODE_FEED_PK_PREFIX", "EPISODE_FEED_SK_PREFIX", "ensureEpisodeIdentity", "ep", "ensureVersion", "now", "pad", "n", "v", "putFeedRecord", "item", "episodeKey", "pk", "sk", "attributes", "key", "value", "event", "nowIso", "targetStatus", "episode", "feedItem", "skippedWrite", "err", "result"]
}
