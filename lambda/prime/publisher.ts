// lambda/prime/publisher.ts

/**
 * Episode Publisher Lambda (Prime Studios)
 *
 * Purpose:
 *  - Final step in the Prime Studios pipeline:
 *      validate episode ‚Üí verify layout ‚Üí publish to public feed.
 *  - Designed to be invoked by Step Functions or internal APIs only.
 *
 * Current behavior:
 *  - Checks layout validation results.
 *  - If invalid ‚Üí returns a failed publish result with error messages.
 *  - If valid ‚Üí returns a successful publish result with a stable feed key.
 *
 * Future evolution:
 *  - Write the canonical episode JSON to S3 using FEED_BUCKET / FEED_PREFIX.
 *  - Update a DynamoDB record to track published versions.
 *  - Emit events to an analytics bus or fan-facing ‚Äúepisode feed‚Äù API.
 */

export interface LayoutCheckReport {
  valid: boolean;
  errors?: string[];
  warnings?: string[];
  // raw layout payload or a reference to it
  layoutSnapshot?: unknown;
}

export interface PublishEpisodeInput {
  episodeId: string;
  versionId?: string;

  // Optional state flags from upstream workflow
  statusBefore?: "READY_FOR_REVIEW" | "READY_FOR_PUBLISH" | "DRAFT";

  // Result from LayoutEngineStack validator lambda
  layoutReport?: LayoutCheckReport;

  // Optional: if true, do everything but the actual write.
  dryRun?: boolean;

  // Arbitrary metadata (e.g. campaign, season, etc.)
  metadata?: Record<string, unknown>;
}

export interface PublishEpisodeResult {
  episodeId: string;
  versionId: string;
  dryRun: boolean;

  published: boolean;

  // Key or path that downstream fan APIs can use to resolve the episode
  feedKey: string;

  // When the publish completed (if published = true)
  publishedAt?: string;

  // If publish failed / was blocked
  errors?: string[];

  // Non-blocking issues from layout checks
  layoutWarnings?: string[];

  // Echo metadata for traceability
  metadata?: Record<string, unknown>;
}

/** Derive a stable versionId if none is provided. */
function inferVersionId(input: PublishEpisodeInput): string {
  if (input.versionId) return input.versionId;
  // Simple autogenerated version; you might replace this with
  // a monotonically increasing version counter based on DB.
  return `v-${Math.random().toString(36).slice(2, 10)}`;
}

/** Construct a deterministic feed key (S3 key, logical path, etc.). */
function buildFeedKey(episodeId: string, versionId: string): string {
  const prefix = process.env.FEED_PREFIX ?? "episodes";
  return `${prefix}/${episodeId}/${versionId}.json`;
}

export const handler = async (
  event: PublishEpisodeInput,
): Promise<PublishEpisodeResult> => {
  console.log("Publisher incoming event:", JSON.stringify(event, null, 2));

  if (!event || !event.episodeId) {
    throw new Error("Missing required field: episodeId");
  }

  const versionId = inferVersionId(event);
  const feedKey = buildFeedKey(event.episodeId, versionId);
  const dryRun = event.dryRun === true;

  const layoutReport = event.layoutReport ?? { valid: true };

  const blockingErrors: string[] = [];

  // Basic rule: layout *must* be valid for publish to succeed.
  if (!layoutReport.valid) {
    blockingErrors.push("Layout validation failed.");
    if (layoutReport.errors && layoutReport.errors.length > 0) {
      blockingErrors.push(...layoutReport.errors);
    }
  }

  // If there are blocking errors, we do NOT publish.
  if (blockingErrors.length > 0) {
    const failedResult: PublishEpisodeResult = {
      episodeId: event.episodeId,
      versionId,
      dryRun,
      published: false,
      feedKey,
      errors: blockingErrors,
      layoutWarnings: layoutReport.warnings ?? [],
      metadata: event.metadata,
    };

    console.warn(
      "Publisher blocked publish due to errors:",
      JSON.stringify(failedResult, null, 2),
    );

    return failedResult;
  }

  // At this point, layout is valid and we can publish (or simulate).
  const publishedAt = new Date().toISOString();

  // üîú Future:
  //   - If !dryRun, write the final episode JSON to S3:
  //       const bucket = process.env.FEED_BUCKET;
  //       const s3Key = feedKey;
  //   - Update a DynamoDB record tying (episodeId, versionId) to this feedKey.
  //   - Emit an EventBridge event to notify fan-facing systems.
  //
  // For now, we just return the logical outcome.

  const successResult: PublishEpisodeResult = {
    episodeId: event.episodeId,
    versionId,
    dryRun,
    published: !dryRun, // If dry-run, "success" but not actually published.
    feedKey,
    publishedAt: dryRun ? undefined : publishedAt,
    layoutWarnings: layoutReport.warnings ?? [],
    metadata: event.metadata,
  };

  console.log("Publisher result:", JSON.stringify(successResult, null, 2));

  return successResult;
};
